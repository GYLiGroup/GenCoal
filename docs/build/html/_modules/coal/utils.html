

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>coal.utils &mdash; GenCoal v1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=0ec76b63"></script>
      <script src="../../_static/doctools.js?v=888ff710"></script>
      <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GenCoal
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/bitumite.html">bitumite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/lignite.html">lignite</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/ClipIRMol.html">ClipIRMol Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/CoalGenerator.html">CoalGenerator Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/utils.html">utils Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/main.html">main Module</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GenCoal</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">coal.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for coal.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">rdkit</span> <span class="kn">import</span> <span class="n">Chem</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">rdchem</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem.rdchem</span> <span class="kn">import</span> <span class="n">BondType</span>
<span class="kn">from</span> <span class="nn">rdkit.Chem</span> <span class="kn">import</span> <span class="n">AddHs</span><span class="p">,</span> <span class="n">Draw</span><span class="p">,</span> <span class="n">AllChem</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">simps</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>

<span class="c1"># NMR integral ------------ create json</span>
<div class="viewcode-block" id="calculate_C90_C180"><a class="viewcode-back" href="../../api/utils.html#coal.utils.calculate_C90_C180">[docs]</a><span class="k">def</span> <span class="nf">calculate_C90_C180</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the integral ratios C90 and C180 from NMR data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_path : str</span>
<span class="sd">        Path to the CSV file containing NMR data with columns &#39;X&#39; and &#39;Y&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple[float, float]</span>
<span class="sd">        Ratios C90 and C180.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 导入数据</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
    
    <span class="c1"># 数据清洗</span>
    <span class="n">filtered_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">250</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">filtered_df</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">filtered_df</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># 创建线性插值函数</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">x_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">y_values</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_values</span><span class="p">)</span>

    <span class="c1"># 使用Simpson积分法计算总面积</span>
    <span class="n">total_area</span> <span class="o">=</span> <span class="n">simps</span><span class="p">(</span><span class="n">y_values</span><span class="p">,</span> <span class="n">x_values</span><span class="p">)</span>

    <span class="c1"># 计算90到最大x值的面积比</span>
    <span class="n">x_90_max</span> <span class="o">=</span> <span class="n">x_values</span><span class="p">[</span><span class="n">x_values</span> <span class="o">&gt;=</span> <span class="mi">90</span><span class="p">]</span>
    <span class="n">y_90_max</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_90_max</span><span class="p">)</span>
    <span class="n">area_90_max</span> <span class="o">=</span> <span class="n">simps</span><span class="p">(</span><span class="n">y_90_max</span><span class="p">,</span> <span class="n">x_90_max</span><span class="p">)</span>
    <span class="n">C90</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">area_90_max</span> <span class="o">/</span> <span class="n">total_area</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># 计算180到最大x值的面积比</span>
    <span class="n">x_180_max</span> <span class="o">=</span> <span class="n">x_values</span><span class="p">[</span><span class="n">x_values</span> <span class="o">&gt;=</span> <span class="mi">180</span><span class="p">]</span>
    <span class="n">y_180_max</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_180_max</span><span class="p">)</span>
    <span class="n">area_180_max</span> <span class="o">=</span> <span class="n">simps</span><span class="p">(</span><span class="n">y_180_max</span><span class="p">,</span> <span class="n">x_180_max</span><span class="p">)</span>
    <span class="n">C180</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">area_180_max</span> <span class="o">/</span> <span class="n">total_area</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># 绘图</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Interpolated Curve&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x_90_max</span><span class="p">,</span> <span class="n">y_90_max</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Area from 90 to Max&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x_180_max</span><span class="p">,</span> <span class="n">y_180_max</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Area from 180 to Max&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Chemical Shift (ppm)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Intensity&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;font&#39;</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="s1">&#39;Palatino&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">C90</span><span class="p">,</span> <span class="n">C180</span></div>

<span class="c1"># Read JSON data</span>
<div class="viewcode-block" id="read_json"><a class="viewcode-back" href="../../api/utils.html#coal.utils.read_json">[docs]</a><span class="k">def</span> <span class="nf">read_json</span><span class="p">(</span><span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reads a JSON file and returns its content.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_name : str</span>
<span class="sd">        Path to the JSON file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        The content of the JSON file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<span class="c1"># Calculate moles of each element based on carbon moles and elemental mass ratios</span>
<div class="viewcode-block" id="calculate_element_moles"><a class="viewcode-back" href="../../api/utils.html#coal.utils.calculate_element_moles">[docs]</a><span class="k">def</span> <span class="nf">calculate_element_moles</span><span class="p">(</span><span class="n">C_moles</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">ele_ratio</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the moles of each element in a compound based on the moles of carbon (C)</span>
<span class="sd">    and the mass percentage ratios of other elements relative to carbon.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C_moles : float</span>
<span class="sd">        The carbon counts in the compound.</span>
<span class="sd">    ele_ratio : dict</span>
<span class="sd">        Elemental percentage (e.g., {&#39;C&#39;: 80, &#39;H&#39;: 10, &#39;O&#39;: 10}).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Number of each element in the compound.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">atomic_masses</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">12.01</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mf">1.008</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="mf">16.00</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="mf">14.01</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="mf">32.07</span><span class="p">}</span>
    
    <span class="n">molar_ratios</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">element</span><span class="p">,</span> <span class="n">mass_percentage</span> <span class="ow">in</span> <span class="n">ele_ratio</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">molar_ratios</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">mass_percentage</span> <span class="o">/</span> <span class="n">atomic_masses</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="k">if</span> <span class="n">mass_percentage</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>

    <span class="n">min_ratio</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ratio</span> <span class="k">for</span> <span class="n">ratio</span> <span class="ow">in</span> <span class="n">molar_ratios</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">ratio</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">))</span>

    <span class="n">relative_molar_ratios</span> <span class="o">=</span> <span class="p">{</span><span class="n">element</span><span class="p">:</span> <span class="n">ratio</span> <span class="o">/</span> <span class="n">min_ratio</span> <span class="k">for</span> <span class="n">element</span><span class="p">,</span> <span class="n">ratio</span> <span class="ow">in</span> <span class="n">molar_ratios</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">ratio</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)}</span>
    <span class="n">given_ratios</span> <span class="o">=</span> <span class="p">{</span><span class="n">element</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span> <span class="k">for</span> <span class="n">element</span><span class="p">,</span> <span class="n">ratio</span> <span class="ow">in</span> <span class="n">relative_molar_ratios</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="n">rounded_relative_molar_ratios</span> <span class="o">=</span> <span class="p">{</span><span class="n">element</span><span class="p">:</span> <span class="n">given_ratios</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">atomic_masses</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

    <span class="n">element_moles</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">element</span><span class="p">,</span> <span class="n">relative_molar_ratio</span> <span class="ow">in</span> <span class="n">rounded_relative_molar_ratios</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">element</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
            <span class="n">element_moles</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="n">C_moles</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">element_moles</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">relative_molar_ratio</span> <span class="o">*</span> <span class="n">C_moles</span> <span class="o">/</span> <span class="n">rounded_relative_molar_ratios</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">element_moles</span></div>


<span class="c1"># Merge atom counts based on SMILES representation</span>
<div class="viewcode-block" id="merge_count_atoms"><a class="viewcode-back" href="../../api/utils.html#coal.utils.merge_count_atoms">[docs]</a><span class="k">def</span> <span class="nf">merge_count_atoms</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the target property of each element of a molecule.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        SMILES of a molecule.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary of atom counts (e.g., {&#39;C_N_ar&#39;: 15, &#39;C_al&#39;: 0, &#39;O_S&#39;: 1, &#39;H&#39;: 7}).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">atom_counts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C_N_ar&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;C_al&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;O_S&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">molecule</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
    <span class="n">molecule</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>  <span class="c1"># Add Hydrogens</span>

    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">or</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetDegree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">atom_counts</span><span class="p">[</span><span class="s1">&#39;C_al&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">atom_counts</span><span class="p">[</span><span class="s1">&#39;C_N_ar&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span> <span class="ow">or</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
            <span class="n">atom_counts</span><span class="p">[</span><span class="s1">&#39;O_S&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
            <span class="n">atom_counts</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">atom_counts</span></div>


<span class="c1"># Sort SMILES based on elemental compositions</span>
<div class="viewcode-block" id="getPackage"><a class="viewcode-back" href="../../api/utils.html#coal.utils.getPackage">[docs]</a><span class="k">def</span> <span class="nf">getPackage</span><span class="p">(</span><span class="n">total_smiles_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sorts a list of SMILES based on their calculated elemental compositions.</span>
<span class="sd">    The sorting criteria prioritize compounds with higher ratios of certain elements to H.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    total_smiles_list : list</span>
<span class="sd">        A list of SMILES.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of SMILES strings sorted according to their elemental composition ratios.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the atom counts and adjust H count for each SMILES string</span>
    <span class="n">adjusted_packages</span> <span class="o">=</span> <span class="p">[{</span>
        <span class="s1">&#39;smiles&#39;</span><span class="p">:</span> <span class="n">smiles</span><span class="p">,</span>
        <span class="o">**</span><span class="n">merge_count_atoms</span><span class="p">(</span><span class="n">smiles</span><span class="p">),</span>  <span class="c1"># Unpack the atom count dictionary</span>
        <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="n">merge_count_atoms</span><span class="p">(</span><span class="n">smiles</span><span class="p">)[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>  <span class="c1"># Adjust H count</span>
    <span class="p">}</span> <span class="k">for</span> <span class="n">smiles</span> <span class="ow">in</span> <span class="n">total_smiles_list</span><span class="p">]</span>

    <span class="c1"># Sort the list of dictionaries based on element ratios</span>
    <span class="n">sorted_adjusted_packages</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="n">adjusted_packages</span><span class="p">,</span> 
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">package</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">package</span><span class="p">[</span><span class="s1">&#39;C_N_ar&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">package</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">package</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span><span class="p">),</span>  <span class="c1"># Avoid division by zero</span>
            <span class="n">package</span><span class="p">[</span><span class="s1">&#39;C_al&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">package</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">package</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">package</span><span class="p">[</span><span class="s1">&#39;O_S&#39;</span><span class="p">]</span>
        <span class="p">),</span> 
        <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Extract the sorted list of SMILES strings</span>
    <span class="n">sorted_smiles_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">package</span><span class="p">[</span><span class="s1">&#39;smiles&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">package</span> <span class="ow">in</span> <span class="n">sorted_adjusted_packages</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">sorted_smiles_list</span></div>


<span class="c1"># Calculate the number of carbonyl and hydroxyl groups</span>
<div class="viewcode-block" id="recommended_carbonyl_hydroxyl"><a class="viewcode-back" href="../../api/utils.html#coal.utils.recommended_carbonyl_hydroxyl">[docs]</a><span class="k">def</span> <span class="nf">recommended_carbonyl_hydroxyl</span><span class="p">(</span><span class="n">C_moles</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">ele_ratio</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the number of carbonyl and hydroxyl groups based on atom counts and compound type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C_moles : float</span>
<span class="sd">        Number of carbon atoms in the compound.</span>
<span class="sd">    ele_ratio : dict</span>
<span class="sd">        Elemental percentage (e.g., {&#39;C&#39;: 80, &#39;H&#39;: 10, &#39;O&#39;: 10}).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple[int, int]</span>
<span class="sd">        The number of carbonyl and hydroxyl groups in the compound.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">atom_num</span> <span class="o">=</span> <span class="n">calculate_element_moles</span><span class="p">(</span><span class="n">C_moles</span><span class="p">,</span> <span class="n">ele_ratio</span><span class="p">)</span>
    
    <span class="n">total_mass</span> <span class="o">=</span> <span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">12</span> <span class="o">+</span> <span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">14</span> <span class="o">+</span> <span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">32</span>

    <span class="n">carbonyl</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">total_mass</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">hydroxyl</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">total_mass</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">carbonyl</span><span class="p">,</span> <span class="n">hydroxyl</span></div>


<span class="c1"># Adjust the target atom counts for a compound</span>
<div class="viewcode-block" id="getTarget"><a class="viewcode-back" href="../../api/utils.html#coal.utils.getTarget">[docs]</a><span class="k">def</span> <span class="nf">getTarget</span><span class="p">(</span><span class="n">C90</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">ele_ratio</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">C_moles</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">carbonyl</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">hydroxyl</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjusts the target atom counts for a chemical compound based on specified carbon moles,</span>
<span class="sd">    elemental mass ratios, and the percentages of carboxyl and hydroxyl groups.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C90 : float</span>
<span class="sd">        The degree of aromaticity.</span>
<span class="sd">    ele_ratio : dict</span>
<span class="sd">        Elemental mass percentages (e.g., {&#39;C&#39;: 80, &#39;H&#39;: 10, &#39;O&#39;: 10}).</span>
<span class="sd">    C_moles : float</span>
<span class="sd">        The number of carbon atoms.</span>
<span class="sd">    carbonyl : int</span>
<span class="sd">        The number of carbonyl groups.</span>
<span class="sd">    hydroxyl : int</span>
<span class="sd">        The number of hydroxyl groups.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple[dict, dict]</span>
<span class="sd">        The calculated chemical formula and the adjusted target atom counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">atom_num</span> <span class="o">=</span> <span class="n">calculate_element_moles</span><span class="p">(</span><span class="n">C_moles</span><span class="p">,</span> <span class="n">ele_ratio</span><span class="p">)</span>

    <span class="c1"># Adjust targets based on carbonyl and hydroxyl values</span>
    <span class="n">adjusted_target</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;C_N_ar&#39;</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">C90</span> <span class="o">+</span> <span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]),</span>
        <span class="s1">&#39;C_al&#39;</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">C90</span><span class="p">)),</span>
        <span class="s1">&#39;O_S&#39;</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">carbonyl</span> <span class="o">-</span> <span class="n">hydroxyl</span><span class="p">),</span>
        <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="n">atom_num</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model has </span><span class="si">{</span><span class="n">carbonyl</span><span class="si">}</span><span class="s2"> O atom in carbonyl&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Model has </span><span class="si">{</span><span class="n">hydroxyl</span><span class="si">}</span><span class="s2"> O atom in hydroxyl&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">atom_num</span><span class="p">,</span> <span class="n">adjusted_target</span></div>
    

<div class="viewcode-block" id="build_H_nested_dict"><a class="viewcode-back" href="../../api/utils.html#coal.utils.build_H_nested_dict">[docs]</a><span class="k">def</span> <span class="nf">build_H_nested_dict</span><span class="p">(</span><span class="n">sorted_choices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a nested dictionary to store the minimum hydrogen (H) values for combinations </span>
<span class="sd">    of carbon-nitrogen aromatic count (C_N_ar) and oxygen-sulfur count (O_S) from a list of compounds.</span>

<span class="sd">    The function iterates over the provided list of compound data (sorted_choices) and for each</span>
<span class="sd">    unique combination of C_N_ar (carbon-nitrogen aromatic count) and O_S (oxygen-sulfur count),</span>
<span class="sd">    it records the minimum hydrogen (H) value. The result is stored in a nested dictionary format </span>
<span class="sd">    where the first level keys are &#39;C_N_ar&#39; values, the second level keys are &#39;O_S&#39; values, and </span>
<span class="sd">    the values are the minimum &#39;H&#39; values for those combinations.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; sorted_choices = [</span>
<span class="sd">    &gt;&gt;&gt;     {&#39;C_N_ar&#39;: 10, &#39;O_S&#39;: 2, &#39;H&#39;: 12},</span>
<span class="sd">    &gt;&gt;&gt;     {&#39;C_N_ar&#39;: 10, &#39;O_S&#39;: 2, &#39;H&#39;: 8},</span>
<span class="sd">    &gt;&gt;&gt;     {&#39;C_N_ar&#39;: 5, &#39;O_S&#39;: 3, &#39;H&#39;: 14}</span>
<span class="sd">    &gt;&gt;&gt; ]</span>
<span class="sd">    &gt;&gt;&gt; build_H_nested_dict(sorted_choices)</span>
<span class="sd">    {10: {2: 8}, 5: {3: 14}}</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function assumes that the input list (`sorted_choices`) is pre-sorted by &#39;C_N_ar&#39; and &#39;O_S&#39; values.</span>
<span class="sd">    - If multiple entries have the same C_N_ar and O_S values, the function will select the minimum H value from those entries.</span>
<span class="sd">    - The function is designed to handle situations where not all combinations of C_N_ar and O_S are present, </span>
<span class="sd">      in which case those combinations will not appear in the output dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nested_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>

    <span class="c1"># Grouping H values into the nested dictionary by C_N_ar and O_S</span>
    <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">sorted_choices</span><span class="p">:</span>
        <span class="n">nested_dict</span><span class="p">[</span><span class="n">choice</span><span class="p">[</span><span class="s1">&#39;C_N_ar&#39;</span><span class="p">]][</span><span class="n">choice</span><span class="p">[</span><span class="s1">&#39;O_S&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">choice</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">])</span>

    <span class="c1"># Finding the minimum H value in each list of H values for a given C_N_ar and O_S combination</span>
    <span class="k">for</span> <span class="n">c_n_ar_key</span> <span class="ow">in</span> <span class="n">nested_dict</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">o_s_key</span> <span class="ow">in</span> <span class="n">nested_dict</span><span class="p">[</span><span class="n">c_n_ar_key</span><span class="p">]:</span>
            <span class="n">nested_dict</span><span class="p">[</span><span class="n">c_n_ar_key</span><span class="p">][</span><span class="n">o_s_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nested_dict</span><span class="p">[</span><span class="n">c_n_ar_key</span><span class="p">][</span><span class="n">o_s_key</span><span class="p">])</span>

    <span class="c1"># Convert defaultdict to a standard dictionary for the final output</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">c_n_ar_key</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">inner_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">c_n_ar_key</span><span class="p">,</span> <span class="n">inner_dict</span> <span class="ow">in</span> <span class="n">nested_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>

<div class="viewcode-block" id="find_combinations"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_combinations">[docs]</a><span class="k">def</span> <span class="nf">find_combinations</span><span class="p">(</span><span class="n">sorted_choices</span><span class="p">,</span> <span class="n">target_C_N_ar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds all unique combinations of &#39;C_N_ar&#39; values from &#39;sorted_choices&#39; that sum up to &#39;target_C_N_ar&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sorted_choices : list of dicts</span>
<span class="sd">        A list of dictionaries where each dictionary contains &#39;C_N_ar&#39; among other keys. </span>
<span class="sd">        This list represents different choices or options, each with a specified &#39;C_N_ar&#39; value.</span>
<span class="sd">    target_C_N_ar : int</span>
<span class="sd">        The target sum of &#39;C_N_ar&#39; values for the combinations to reach.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of dicts</span>
<span class="sd">        A list where each dictionary represents a unique combination of &#39;C_N_ar&#39; values that sum up to &#39;target_C_N_ar&#39;. The keys in each dictionary are the &#39;C_N_ar&#39; values used, and the values are the counts of each &#39;C_N_ar&#39; value in the combination.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; sorted_choices = [</span>
<span class="sd">        {&#39;C_N_ar&#39;: 2, &#39;O_S&#39;: 3, &#39;H&#39;: 7},</span>
<span class="sd">        {&#39;C_N_ar&#39;: 3, &#39;O_S&#39;: 2, &#39;H&#39;: 6},</span>
<span class="sd">        {&#39;C_N_ar&#39;: 5, &#39;O_S&#39;: 1, &#39;H&#39;: 8}</span>
<span class="sd">    ]</span>
<span class="sd">    &gt;&gt;&gt; find_combinations(sorted_choices, 5)</span>
<span class="sd">    [{2: 1, 3: 1}, {5: 1}]</span>
<span class="sd">   &quot;&quot;&quot;</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">choice</span><span class="p">[</span><span class="s1">&#39;C_N_ar&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">sorted_choices</span><span class="p">))</span>
    <span class="n">candidates</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">start</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">candidates</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">target</span> <span class="o">-</span> <span class="n">candidates</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">candidates</span><span class="p">[</span><span class="n">start</span><span class="p">]],</span> <span class="n">res</span><span class="p">)</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">target_C_N_ar</span><span class="p">,</span> <span class="p">[],</span> <span class="n">res</span><span class="p">)</span>

    <span class="n">cn_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
        <span class="n">temp_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">combination</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">}</span>
        <span class="n">cn_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_dict</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">cn_list</span></div>


<div class="viewcode-block" id="backtrack_combinations"><a class="viewcode-back" href="../../api/utils.html#coal.utils.backtrack_combinations">[docs]</a><span class="k">def</span> <span class="nf">backtrack_combinations</span><span class="p">(</span><span class="n">nested_dict_H</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> 
                            <span class="n">selection_dic</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                            <span class="n">target_O_S</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
                            <span class="n">max_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds valid combinations of hydrogen (H) counts that match a specified target for oxygen-sulfur (O_S) count </span>
<span class="sd">    using a backtracking algorithm. This function explores all possible combinations of H and O_S values to </span>
<span class="sd">    find combinations that meet the target O_S sum and the required hydrogen counts specified in `selection_dic`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nested_dict_H : Dict[int, Dict[int, int]]</span>
<span class="sd">        A nested dictionary where the first level keys are hydrogen counts (H) and the second level keys are </span>
<span class="sd">        oxygen-sulfur counts (O_S). The values are the available counts for each hydrogen (H) and oxygen-sulfur (O_S) combination.</span>
<span class="sd">    </span>
<span class="sd">    selection_dic : Dict[int, int]</span>
<span class="sd">        A dictionary where the keys represent hydrogen counts (H) and the values represent the total number of times</span>
<span class="sd">        each hydrogen count must be used in the final solution.</span>

<span class="sd">    target_O_S : int</span>
<span class="sd">        The target sum of oxygen-sulfur (O_S) values that the selected combinations of H and O_S should match.</span>

<span class="sd">    max_depth : int, optional</span>
<span class="sd">        The maximum depth to which the backtracking algorithm will explore. Default is 30. This helps control the recursion depth</span>
<span class="sd">        and avoid excessive computation for large inputs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    List[Dict[int, Dict[int, int]]]</span>
<span class="sd">        A list of dictionaries, where each dictionary represents a valid combination of hydrogen (H) and oxygen-sulfur (O_S)</span>
<span class="sd">        values that satisfy the target O_S sum and adhere to the required hydrogen counts as specified in `selection_dic`.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; nested_dict_H = {</span>
<span class="sd">    &gt;&gt;&gt;     12: {2: 3, 3: 5},</span>
<span class="sd">    &gt;&gt;&gt;     8: {2: 4, 3: 2},</span>
<span class="sd">    &gt;&gt;&gt; }</span>
<span class="sd">    &gt;&gt;&gt; selection_dic = {12: 2, 8: 1}</span>
<span class="sd">    &gt;&gt;&gt; target_O_S = 5</span>
<span class="sd">    &gt;&gt;&gt; backtrack_combinations(nested_dict_H, selection_dic, target_O_S)</span>
<span class="sd">    [{&#39;12&#39;: {2: 1, 3: 1}, &#39;8&#39;: {2: 1}}]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function employs a depth-first search (DFS) approach to explore potential combinations and uses memoization </span>
<span class="sd">      to avoid recomputing previously explored paths.</span>
<span class="sd">    - If a solution exceeds the `max_depth`, the function will stop further exploration.</span>
<span class="sd">    - The function returns multiple valid solutions if they exist.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Sort H keys in descending order for optimization</span>
    <span class="n">H_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nested_dict_H</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">convert_to_hashable</span><span class="p">(</span><span class="n">current_selection</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the current selection dictionary into a hashable type (tuple) for memoization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current_selection : Dict[int, Dict[int, int]]</span>
<span class="sd">            A dictionary representing the current selection of hydrogen (H) and oxygen-sulfur (O_S) counts. </span>
<span class="sd">            This dictionary is used to track the ongoing selection during backtracking.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple</span>
<span class="sd">            A tuple representation of the current selection dictionary, making it hashable for memoization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">current_selection</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">remaining_O_S</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">H_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">current_selection</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursive backtracking function to explore combinations of hydrogen (H) and oxygen-sulfur (O_S) values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remaining_O_S : int</span>
<span class="sd">            The remaining oxygen-sulfur sum that needs to be matched during backtracking.</span>

<span class="sd">        H_index : int</span>
<span class="sd">            The index in the list of hydrogen (H) keys indicating the current hydrogen value being processed.</span>

<span class="sd">        current_selection : Dict[int, Dict[int, int]]</span>
<span class="sd">            A dictionary representing the current selection of hydrogen (H) and oxygen-sulfur (O_S) counts. </span>

<span class="sd">        depth : int</span>
<span class="sd">            The current depth of recursion in the backtracking process. Used to control recursion limit.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Dict[int, Dict[int, int]]]</span>
<span class="sd">            A list of valid combinations where the hydrogen counts match the selection criteria, and the O_S sum is met.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Base case: Stop if maximum depth is exceeded</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="n">max_depth</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="c1"># Check memo to avoid re-exploring known paths</span>
        <span class="n">hashable_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">remaining_O_S</span><span class="p">,</span> <span class="n">H_index</span><span class="p">,</span> <span class="n">convert_to_hashable</span><span class="p">(</span><span class="n">current_selection</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">hashable_key</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Successful case: If target O_S is met and all H counts match selection criteria</span>
        <span class="k">if</span> <span class="n">remaining_O_S</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">current_selection</span><span class="p">[</span><span class="n">H</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="n">selection_dic</span><span class="p">[</span><span class="n">H</span><span class="p">]</span> <span class="k">for</span> <span class="n">H</span> <span class="ow">in</span> <span class="n">H_keys</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">current_selection</span><span class="p">)]</span>

        <span class="c1"># Base case: Stop if index out of bounds or negative target</span>
        <span class="k">if</span> <span class="n">H_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H_keys</span><span class="p">)</span> <span class="ow">or</span> <span class="n">remaining_O_S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">current_H</span> <span class="o">=</span> <span class="n">H_keys</span><span class="p">[</span><span class="n">H_index</span><span class="p">]</span>
        <span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Explore next H value without adding current H</span>
        <span class="n">solutions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">backtrack</span><span class="p">(</span><span class="n">remaining_O_S</span><span class="p">,</span> <span class="n">H_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_selection</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Try adding current H and explore further</span>
        <span class="k">for</span> <span class="n">O_S</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">nested_dict_H</span><span class="p">[</span><span class="n">current_H</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">current_selection</span><span class="p">[</span><span class="n">current_H</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">selection_dic</span><span class="p">[</span><span class="n">current_H</span><span class="p">]:</span>
                <span class="n">current_selection</span><span class="p">[</span><span class="n">current_H</span><span class="p">][</span><span class="n">O_S</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">solutions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="n">backtrack</span><span class="p">(</span><span class="n">remaining_O_S</span> <span class="o">-</span> <span class="n">O_S</span><span class="p">,</span> <span class="n">H_index</span><span class="p">,</span> <span class="n">current_selection</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">current_selection</span><span class="p">[</span><span class="n">current_H</span><span class="p">][</span><span class="n">O_S</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">memo</span><span class="p">[</span><span class="n">hashable_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">solutions</span>

    <span class="c1"># Initialize the selection with zeros for each possible O_S count under each H key</span>
    <span class="n">initial_selection</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">{</span><span class="n">subkey</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">nested_dict_H</span><span class="p">[</span><span class="n">key</span><span class="p">]}</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">nested_dict_H</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="n">backtrack</span><span class="p">(</span><span class="n">target_O_S</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">initial_selection</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Start backtracking with initial conditions</span>

    <span class="k">return</span> <span class="n">solutions</span></div>

<div class="viewcode-block" id="parallel_backtrack_combinations"><a class="viewcode-back" href="../../api/utils.html#coal.utils.parallel_backtrack_combinations">[docs]</a><span class="k">def</span> <span class="nf">parallel_backtrack_combinations</span><span class="p">(</span><span class="n">nested_dict_H</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> 
                                    <span class="n">selection_dic</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> 
                                    <span class="n">target_O_S</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
                                    <span class="n">max_depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> 
                                    <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parallelized version of backtracking to find combinations of hydrogen (H) and oxygen-sulfur (O_S) values </span>
<span class="sd">    that match a specified target O_S sum, using multiple cores for faster computation. This function explores all </span>
<span class="sd">    possible combinations of H and O_S values and finds those that meet the target O_S sum while adhering to the </span>
<span class="sd">    required hydrogen counts specified in `selection_dic`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nested_dict_H : Dict[int, Dict[int, int]]</span>
<span class="sd">        A nested dictionary where the first level keys represent hydrogen counts (H) and the second level keys </span>
<span class="sd">        represent oxygen-sulfur (O_S) values. The values in the dictionary represent the number of times each H-O_S </span>
<span class="sd">        combination can be used.</span>

<span class="sd">    selection_dic : Dict[int, int]</span>
<span class="sd">        A dictionary where the keys represent hydrogen counts (H) and the values represent the total number of times </span>
<span class="sd">        each hydrogen count must be used in the solution.</span>

<span class="sd">    target_O_S : int</span>
<span class="sd">        The target sum of oxygen-sulfur (O_S) values that the selected combinations of H and O_S should match.</span>

<span class="sd">    max_depth : int, optional</span>
<span class="sd">        The maximum depth to which the backtracking algorithm will explore. Default is 50. This parameter is used to control </span>
<span class="sd">        the recursion depth in the backtracking algorithm, helping to avoid excessive computation for larger inputs.</span>

<span class="sd">    n_jobs : int, optional</span>
<span class="sd">        The number of parallel jobs (cores) to use for processing the subtasks. Default is 40. This controls how many parallel </span>
<span class="sd">        processes the algorithm will use to speed up the backtracking computation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    List[Dict[int, Dict[int, int]]]</span>
<span class="sd">        A list of dictionaries, where each dictionary represents a valid combination of hydrogen (H) and oxygen-sulfur (O_S) </span>
<span class="sd">        values that satisfy the target O_S sum and the required hydrogen counts as specified in `selection_dic`.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; nested_dict_H = {</span>
<span class="sd">    &gt;&gt;&gt;     12: {2: 3, 3: 5},</span>
<span class="sd">    &gt;&gt;&gt;     8: {2: 4, 3: 2},</span>
<span class="sd">    &gt;&gt;&gt; }</span>
<span class="sd">    &gt;&gt;&gt; selection_dic = {12: 2, 8: 1}</span>
<span class="sd">    &gt;&gt;&gt; target_O_S = 5</span>
<span class="sd">    &gt;&gt;&gt; parallel_backtrack_combinations(nested_dict_H, selection_dic, target_O_S, max_depth=50, n_jobs=4)</span>
<span class="sd">    [{&#39;12&#39;: {2: 1, 3: 1}, &#39;8&#39;: {2: 1}}]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function divides the work into subtasks for parallelization by distributing the combinations to multiple cores.</span>
<span class="sd">    - It uses the `joblib` library for parallel execution, allowing efficient use of multiple CPU cores.</span>
<span class="sd">    - If a solution exceeds the `max_depth`, the function will stop further exploration for that branch.</span>
<span class="sd">    - The function returns all valid combinations that meet the target O_S sum and hydrogen count criteria.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Sort H keys in descending order for optimization</span>
    <span class="n">H_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nested_dict_H</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_to_hashable</span><span class="p">(</span><span class="n">current_selection</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the current selection dictionary into a hashable type (tuple) for memoization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current_selection : Dict[int, Dict[int, int]]</span>
<span class="sd">            A dictionary representing the current selection of hydrogen (H) and oxygen-sulfur (O_S) counts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple</span>
<span class="sd">            A tuple representation of the current selection dictionary, making it hashable for memoization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">current_selection</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">remaining_O_S</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">H_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">current_selection</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> 
                  <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">memo</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursive backtracking function to explore combinations of hydrogen (H) and oxygen-sulfur (O_S) values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        remaining_O_S : int</span>
<span class="sd">            The remaining oxygen-sulfur sum that needs to be matched during backtracking.</span>

<span class="sd">        H_index : int</span>
<span class="sd">            The index in the list of hydrogen (H) keys indicating the current hydrogen value being processed.</span>

<span class="sd">        current_selection : Dict[int, Dict[int, int]]</span>
<span class="sd">            A dictionary representing the current selection of hydrogen (H) and oxygen-sulfur (O_S) counts.</span>

<span class="sd">        depth : int</span>
<span class="sd">            The current depth of recursion in the backtracking process. Used to control recursion limit.</span>

<span class="sd">        memo : Dict</span>
<span class="sd">            A dictionary used for memoization to avoid redundant calculations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Dict[int, Dict[int, int]]]</span>
<span class="sd">            A list of valid combinations where the hydrogen counts match the selection criteria, and the O_S sum is met.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Base case: Stop if maximum depth is exceeded</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="n">max_depth</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        
        <span class="c1"># Check memo to avoid re-exploring known paths</span>
        <span class="n">hashable_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">remaining_O_S</span><span class="p">,</span> <span class="n">H_index</span><span class="p">,</span> <span class="n">convert_to_hashable</span><span class="p">(</span><span class="n">current_selection</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">hashable_key</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Successful case: If target O_S is met and all H counts match selection criteria</span>
        <span class="k">if</span> <span class="n">remaining_O_S</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span><span class="n">current_selection</span><span class="p">[</span><span class="n">H</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="n">selection_dic</span><span class="p">[</span><span class="n">H</span><span class="p">]</span> <span class="k">for</span> <span class="n">H</span> <span class="ow">in</span> <span class="n">H_keys</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">current_selection</span><span class="p">)]</span>

        <span class="c1"># Base case: Stop if index out of bounds or negative target</span>
        <span class="k">if</span> <span class="n">H_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H_keys</span><span class="p">)</span> <span class="ow">or</span> <span class="n">remaining_O_S</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">current_H</span> <span class="o">=</span> <span class="n">H_keys</span><span class="p">[</span><span class="n">H_index</span><span class="p">]</span>
        <span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Explore next H value without adding current H</span>
        <span class="n">solutions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">backtrack</span><span class="p">(</span><span class="n">remaining_O_S</span><span class="p">,</span> <span class="n">H_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">current_selection</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>

        <span class="c1"># Try adding current H and explore further</span>
        <span class="k">for</span> <span class="n">O_S</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">nested_dict_H</span><span class="p">[</span><span class="n">current_H</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">current_selection</span><span class="p">[</span><span class="n">current_H</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">selection_dic</span><span class="p">[</span><span class="n">current_H</span><span class="p">]:</span>
                <span class="n">current_selection</span><span class="p">[</span><span class="n">current_H</span><span class="p">][</span><span class="n">O_S</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">solutions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="n">backtrack</span><span class="p">(</span><span class="n">remaining_O_S</span> <span class="o">-</span> <span class="n">O_S</span><span class="p">,</span> <span class="n">H_index</span><span class="p">,</span> <span class="n">current_selection</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">current_selection</span><span class="p">[</span><span class="n">current_H</span><span class="p">][</span><span class="n">O_S</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">memo</span><span class="p">[</span><span class="n">hashable_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">solutions</span>

    <span class="k">def</span> <span class="nf">generate_subtasks</span><span class="p">(</span><span class="n">nested_dict_H</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate finer-grained subtasks for parallelization by iterating through H and O_S combinations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nested_dict_H : Dict[int, Dict[int, int]]</span>
<span class="sd">            A nested dictionary where the first level keys represent hydrogen counts (H) and the second level keys</span>
<span class="sd">            represent oxygen-sulfur counts (O_S). The values represent the number of available combinations for each.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Tuple[int, int]]</span>
<span class="sd">            A list of subtasks, where each subtask is a tuple consisting of a hydrogen count (H) and an oxygen-sulfur</span>
<span class="sd">            count (O_S).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subtasks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">H_key</span><span class="p">,</span> <span class="n">sub_dict</span> <span class="ow">in</span> <span class="n">nested_dict_H</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">O_S_key</span> <span class="ow">in</span> <span class="n">sub_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">subtasks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">H_key</span><span class="p">,</span> <span class="n">O_S_key</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">subtasks</span>

    <span class="k">def</span> <span class="nf">backtrack_for_subtask</span><span class="p">(</span><span class="n">H_key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">O_S_key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform backtracking for a specific H and O_S combination.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        H_key : int</span>
<span class="sd">            The hydrogen count (H) for this subtask.</span>

<span class="sd">        O_S_key : int</span>
<span class="sd">            The oxygen-sulfur count (O_S) for this subtask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[Dict[int, Dict[int, int]]]</span>
<span class="sd">            A list of valid combinations for the given H and O_S combination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">initial_selection</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="p">{</span><span class="n">subkey</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">nested_dict_H</span><span class="p">[</span><span class="n">key</span><span class="p">]}</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">nested_dict_H</span>
        <span class="p">}</span>
        <span class="n">initial_selection</span><span class="p">[</span><span class="n">H_key</span><span class="p">][</span><span class="n">O_S_key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Initialize with one choice</span>
        <span class="n">remaining_O_S</span> <span class="o">=</span> <span class="n">target_O_S</span> <span class="o">-</span> <span class="n">O_S_key</span>
        <span class="k">return</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">remaining_O_S</span><span class="p">,</span> <span class="n">H_keys</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">H_key</span><span class="p">),</span> <span class="n">initial_selection</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>

    <span class="c1"># Generate finer-grained subtasks</span>
    <span class="n">subtasks</span> <span class="o">=</span> <span class="n">generate_subtasks</span><span class="p">(</span><span class="n">nested_dict_H</span><span class="p">)</span>

    <span class="c1"># Parallel execution</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
        <span class="n">delayed</span><span class="p">(</span><span class="n">backtrack_for_subtask</span><span class="p">)(</span><span class="n">H_key</span><span class="p">,</span> <span class="n">O_S_key</span><span class="p">)</span> <span class="k">for</span> <span class="n">H_key</span><span class="p">,</span> <span class="n">O_S_key</span> <span class="ow">in</span> <span class="n">subtasks</span>
    <span class="p">)</span>

    <span class="c1"># Combine results</span>
    <span class="n">combined_solutions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">combined_solutions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">combined_solutions</span></div>


<div class="viewcode-block" id="find_matching_indices"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_matching_indices">[docs]</a><span class="k">def</span> <span class="nf">find_matching_indices</span><span class="p">(</span><span class="n">selection</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> 
                          <span class="n">sorted_choices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds indices in &#39;sorted_choices&#39; that match the criteria specified in &#39;selection&#39;,</span>
<span class="sd">    considering constraints on repetition and randomly selecting from matching indices </span>
<span class="sd">    while adhering to the repetition limits.</span>

<span class="sd">    This function takes a nested dictionary &#39;selection&#39; that specifies how many times each </span>
<span class="sd">    combination of &#39;C_N_ar&#39; and &#39;O_S&#39; should be selected, then finds the corresponding </span>
<span class="sd">    indices from &#39;sorted_choices&#39; that meet these criteria while enforcing limits on the </span>
<span class="sd">    number of times each index can be chosen.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    selection : dict</span>
<span class="sd">        A nested dictionary where the first level keys represent &#39;C_N_ar&#39; values, and the second </span>
<span class="sd">        level keys represent &#39;O_S&#39; values. The values are integers indicating how many times that </span>
<span class="sd">        specific combination of &#39;C_N_ar&#39; and &#39;O_S&#39; should be selected.</span>

<span class="sd">    sorted_choices : list of dicts</span>
<span class="sd">        A list where each dictionary represents a possible choice. Each dictionary contains keys such </span>
<span class="sd">        as &#39;C_N_ar&#39; and &#39;O_S&#39; among others. These are the possible combinations from which the function </span>
<span class="sd">        selects the matching indices according to the specified criteria in &#39;selection&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices : list of int</span>
<span class="sd">        A list of indices from &#39;sorted_choices&#39; that match the &#39;selection&#39; criteria. Each index corresponds </span>
<span class="sd">        to an entry in &#39;sorted_choices&#39; that fits one of the combinations specified in &#39;selection&#39;. </span>
<span class="sd">        The indices are chosen while respecting the maximum repetition allowed for each index.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; selection = {2: {3: 2}, 4: {5: 1}}</span>
<span class="sd">    &gt;&gt;&gt; sorted_choices = [{&#39;C_N_ar&#39;: 2, &#39;O_S&#39;: 3}, {&#39;C_N_ar&#39;: 2, &#39;O_S&#39;: 3}, {&#39;C_N_ar&#39;: 4, &#39;O_S&#39;: 5}]</span>
<span class="sd">    &gt;&gt;&gt; find_matching_indices(selection, sorted_choices)</span>
<span class="sd">    [0, 1, 2]</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function ensures that each index is selected within the limit specified by &#39;selection&#39;.</span>
<span class="sd">    - Random selection is used from matching indices, and the selection is done uniformly with respect to </span>
<span class="sd">      the repetition constraints.</span>
<span class="sd">    - If there are more requested selections than matching options, the available indices will be selected </span>
<span class="sd">      multiple times while adhering to the specified repeat limits.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">max_repeat_times</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Tracks the number of times each index is selected</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">selection</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Identify all indices that match the current &#39;C_N_ar&#39; and &#39;O_S&#39; criteria</span>
                <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">choice</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_choices</span><span class="p">)</span> 
                           <span class="k">if</span> <span class="n">choice</span><span class="p">[</span><span class="s1">&#39;C_N_ar&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span> <span class="ow">and</span> <span class="n">choice</span><span class="p">[</span><span class="s1">&#39;O_S&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">subkey</span><span class="p">]</span>
                <span class="c1"># Calculate the maximum allowed repeats for each index to distribute selections evenly</span>
                <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>
                    <span class="n">max_repeats</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                        <span class="n">max_repeat_times</span><span class="p">[</span><span class="n">match</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_repeats</span>

                <span class="c1"># Randomly select among the matching indices, considering repeat limits</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">selection</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">]):</span>
                    <span class="n">valid_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">matches</span> <span class="k">if</span> <span class="n">max_repeat_times</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">valid_matches</span><span class="p">:</span>
                        <span class="n">selected</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">valid_matches</span><span class="p">)</span>
                        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">selected</span><span class="p">)</span>
                        <span class="c1"># Decrease the allowed repeats for the selected index</span>
                        <span class="n">max_repeat_times</span><span class="p">[</span><span class="n">selected</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">indices</span></div>

<div class="viewcode-block" id="generate_candidate_smiles"><a class="viewcode-back" href="../../api/utils.html#coal.utils.generate_candidate_smiles">[docs]</a><span class="k">def</span> <span class="nf">generate_candidate_smiles</span><span class="p">(</span><span class="n">min_H_selection</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> 
                               <span class="n">sorted_choices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> 
                               <span class="n">sorted_smiles_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> 
                               <span class="n">target_C_al</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a list of candidate SMILES strings based on a selection criteria, </span>
<span class="sd">    and calculates the predicted chemical formula for these candidates, adjusting </span>
<span class="sd">    for a target count of aliphatic carbon (C_al).</span>

<span class="sd">    This function selects candidate SMILES strings from a given list based on the hydrogen </span>
<span class="sd">    selection criteria provided in `min_H_selection`. After selecting the candidates, </span>
<span class="sd">    it calculates the total number of aliphatic carbon atoms (C_al) and adjusts the selection </span>
<span class="sd">    to meet the target number of aliphatic carbons specified by `target_C_al`. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    min_H_selection : dict</span>
<span class="sd">        A nested dictionary specifying the minimum selection criteria for hydrogen counts in </span>
<span class="sd">        the candidates. The keys represent the hydrogen groupings, and the values indicate </span>
<span class="sd">        the number of selections for each combination.</span>

<span class="sd">    sorted_choices : list of dicts</span>
<span class="sd">        A list of dictionaries where each dictionary contains properties like &#39;C_N_ar&#39;, &#39;C_al&#39;, </span>
<span class="sd">        &#39;O_S&#39;, and &#39;H&#39; counts corresponding to possible chemical choices.</span>

<span class="sd">    sorted_smiles_list : list of str</span>
<span class="sd">        A list of SMILES strings corresponding to the chemical choices in `sorted_choices`.</span>

<span class="sd">    target_C_al : int</span>
<span class="sd">        The target total number of aliphatic carbon atoms (C_al) that the final set of selected </span>
<span class="sd">        candidates should contain.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        - A list of selected candidate SMILES strings that meet the selection criteria.</span>
<span class="sd">        - A string representing the predicted chemical formula of the combined candidates, </span>
<span class="sd">          adjusting for any additional carbon atoms to meet the target C_al count.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; min_H_selection = {2: {3: 2}, 4: {5: 1}}</span>
<span class="sd">    &gt;&gt;&gt; sorted_choices = [{&#39;C_N_ar&#39;: 2, &#39;C_al&#39;: 3, &#39;O_S&#39;: 2, &#39;H&#39;: 5}, {&#39;C_N_ar&#39;: 2, &#39;C_al&#39;: 4, &#39;O_S&#39;: 1, &#39;H&#39;: 4}]</span>
<span class="sd">    &gt;&gt;&gt; sorted_smiles_list = [&#39;CC(C)C&#39;, &#39;CCO&#39;]</span>
<span class="sd">    &gt;&gt;&gt; target_C_al = 8</span>
<span class="sd">    &gt;&gt;&gt; generate_candidate_smiles(min_H_selection, sorted_choices, sorted_smiles_list, target_C_al)</span>
<span class="sd">    ([&#39;CC(C)C&#39;, &#39;CCO&#39;, &#39;C&#39;, &#39;C&#39;], &#39;C4H8O2&#39;)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function selects candidates based on hydrogen counts and the corresponding </span>
<span class="sd">      SMILES strings.</span>
<span class="sd">    - If the total C_al value from selected candidates is less than the target, extra </span>
<span class="sd">      carbon atoms are added (represented as &#39;C&#39;) to meet the required target.</span>
<span class="sd">    - The final chemical formula is calculated based on the selected candidates and the </span>
<span class="sd">      added carbon atoms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find matching indices based on the minimum hydrogen selection criteria</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">find_matching_indices</span><span class="p">(</span><span class="n">min_H_selection</span><span class="p">,</span> <span class="n">sorted_choices</span><span class="p">)</span>
    
    <span class="c1"># Generate a list of selected candidate SMILES strings based on the indices</span>
    <span class="n">candidate_smiles_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">sorted_smiles_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    
    <span class="c1"># Generate legends (string representations) of the selected choices</span>
    <span class="n">selected_legends</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">sorted_choices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>

    <span class="c1"># Extract &#39;C_al&#39; values from the selected choices&#39; legends</span>
    <span class="n">C_al_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">legend</span><span class="p">)[</span><span class="s1">&#39;C_al&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">legend</span> <span class="ow">in</span> <span class="n">selected_legends</span><span class="p">]</span>
    <span class="n">total_C_al</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">C_al_values</span><span class="p">)</span>  <span class="c1"># Calculate the total C_al count</span>
    <span class="n">additional_C_al</span> <span class="o">=</span> <span class="n">target_C_al</span> <span class="o">-</span> <span class="n">total_C_al</span>  <span class="c1"># Calculate how many extra carbon atoms are needed</span>
    <span class="n">added_value</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">additional_C_al</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Ensure no negative values for added carbon atoms</span>

    <span class="c1"># Add extra carbon atoms if necessary to meet the target C_al</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">added_value</span><span class="p">):</span>
        <span class="n">candidate_smiles_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

    <span class="c1"># Count the atoms in the selected candidates and the additional carbon atoms</span>
    <span class="n">element_counts</span> <span class="o">=</span> <span class="n">count_atoms</span><span class="p">(</span><span class="n">candidate_smiles_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">candidate_smiles_list</span><span class="p">,</span> <span class="n">element_counts</span></div>

<div class="viewcode-block" id="find_min_H_selection"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_min_H_selection">[docs]</a><span class="k">def</span> <span class="nf">find_min_H_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_final_selections</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the selection from all possible combinations that results in the minimum total hydrogen (H) count.</span>

<span class="sd">    This function evaluates a list of possible selections (`all_final_selections`) and calculates the total </span>
<span class="sd">    hydrogen (H) count for each selection. It then returns the selection with the minimum hydrogen count. </span>
<span class="sd">    The total H count for a selection is computed by iterating through each hydrogen value and its respective </span>
<span class="sd">    counts in the selection, using the data from `self.nested_dict_H` to calculate the contribution of each </span>
<span class="sd">    combination.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    all_final_selections : list of dict</span>
<span class="sd">        A list of dictionaries where each dictionary represents a potential selection of combinations. </span>
<span class="sd">        Each dictionary contains keys representing hydrogen (H) values and their associated oxygen-sulfur (O_S) values, </span>
<span class="sd">        with counts indicating how many times a specific combination is chosen.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        The selection (a dictionary) from `all_final_selections` that has the minimum total hydrogen count. </span>
<span class="sd">        If there are multiple selections with the same total hydrogen count, the first one encountered will be returned.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; all_final_selections = [</span>
<span class="sd">    &gt;&gt;&gt;     {2: {3: 1, 4: 2}, 4: {5: 1}},</span>
<span class="sd">    &gt;&gt;&gt;     {2: {3: 3}, 4: {5: 2}},</span>
<span class="sd">    &gt;&gt;&gt; ]</span>
<span class="sd">    &gt;&gt;&gt; find_min_H_selection(all_final_selections)</span>
<span class="sd">    {2: {3: 1, 4: 2}, 4: {5: 1}}</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function calculates the total hydrogen count by iterating through each hydrogen value (H) </span>
<span class="sd">      and its respective oxygen-sulfur (O_S) combinations, multiplying the counts by the corresponding </span>
<span class="sd">      values from `self.nested_dict_H`.</span>
<span class="sd">    - The selection with the smallest total H count is returned. This can be useful for minimizing resource </span>
<span class="sd">      usage or optimizing a process that relies on hydrogen consumption.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize variables to track the minimum hydrogen count and the corresponding selection</span>
    <span class="n">min_total_H</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="n">min_H_selection</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Iterate through each selection to calculate its total H count</span>
    <span class="k">for</span> <span class="n">selection</span> <span class="ow">in</span> <span class="n">all_final_selections</span><span class="p">:</span>
        <span class="n">total_H</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Iterate through each H value in the selection</span>
        <span class="k">for</span> <span class="n">H</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">:</span>
            <span class="c1"># Iterate through each O_S value under the current H and accumulate the total H</span>
            <span class="k">for</span> <span class="n">O_S</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">selection</span><span class="p">[</span><span class="n">H</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">total_H</span> <span class="o">+=</span> <span class="n">count</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested_dict_H</span><span class="p">[</span><span class="n">H</span><span class="p">][</span><span class="n">O_S</span><span class="p">]</span>

        <span class="c1"># If the current selection&#39;s total H is less than the minimum found so far, update min_total_H and min_H_selection</span>
        <span class="k">if</span> <span class="n">total_H</span> <span class="o">&lt;</span> <span class="n">min_total_H</span><span class="p">:</span>
            <span class="n">min_total_H</span> <span class="o">=</span> <span class="n">total_H</span>
            <span class="n">min_H_selection</span> <span class="o">=</span> <span class="n">selection</span>

    <span class="k">return</span> <span class="n">min_H_selection</span></div>


<div class="viewcode-block" id="show_atom_number"><a class="viewcode-back" href="../../api/utils.html#coal.utils.show_atom_number">[docs]</a><span class="k">def</span> <span class="nf">show_atom_number</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Label each atom in the given molecule with its index.</span>

<span class="sd">    This function modifies the input RDKit molecule by adding a property to each atom </span>
<span class="sd">    that stores its index. This index can later be accessed using the provided label.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol : rdkit.Chem.Mol</span>
<span class="sd">        The RDKit molecule object whose atoms are to be labeled. This object is modified in place.</span>
<span class="sd">    label : str</span>
<span class="sd">        The label under which the atom index will be stored. This label can then be used to access the atom index from the atom properties.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mol : rdkit.Chem.Mol</span>
<span class="sd">        The RDKit molecule object with atoms labeled with their indices. Note that the molecule is modified in place, </span>
<span class="sd">        so the returned object is the same as the input object.</span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; mol = Chem.MolFromSmiles(&#39;CCO&#39;)</span>
<span class="sd">    &gt;&gt;&gt; labeled_mol = show_atom_number(mol, &#39;atom_index&#39;)</span>
<span class="sd">    &gt;&gt;&gt; for atom in labeled_mol.GetAtoms():</span>
<span class="sd">    &gt;&gt;&gt;     print(atom.GetProp(&#39;atom_index&#39;))</span>
<span class="sd">    0</span>
<span class="sd">    1</span>
<span class="sd">    2</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The atom index is stored as a string property under the specified `label`.</span>
<span class="sd">    - This function is useful for identifying and tracking individual atoms in a molecule, especially when performing atom-level analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="n">atom</span><span class="o">.</span><span class="n">SetProp</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">mol</span></div>


<div class="viewcode-block" id="find_required_aldehyde_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_required_aldehyde_carbons">[docs]</a><span class="k">def</span> <span class="nf">find_required_aldehyde_carbons</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies carbon atoms in a molecule that are part of an aldehyde group. </span>
<span class="sd">    An aldehyde carbon is defined as a carbon atom having exactly three neighbors: </span>
<span class="sd">    one carbon (C), one hydrogen (H), and one oxygen (O).</span>

<span class="sd">    This function processes a SMILES string to identify the aldehyde group carbon atoms </span>
<span class="sd">    by checking their neighbors and ensures that the carbon atom meets the criteria for being part of an aldehyde group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        A SMILES string representing the molecular structure.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of indices corresponding to carbon atoms that are part of an aldehyde group within the molecule. </span>
<span class="sd">        Atom indices are zero-based, matching the order in which atoms appear in the RDKit molecule object.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; find_required_aldehyde_carbons(&#39;C=O&#39;)</span>
<span class="sd">    [0]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function creates an RDKit molecule object from the provided SMILES string and adds hydrogens explicitly to the molecule for better atom detection.</span>
<span class="sd">    - The carbon atoms are considered part of an aldehyde if they are bonded to one hydrogen, one carbon, and one oxygen atom.</span>
<span class="sd">    - This can be useful in synthetic chemistry or molecular analysis where aldehyde functionalities need to be identified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a molecule object from SMILES and add hydrogens explicitly</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">))</span>

    <span class="c1"># Initialize a list to store indices of carbon atoms that are part of an aldehyde group</span>
    <span class="n">carbons</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate through each atom in the molecule</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="c1"># Check if the atom is a carbon</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
            <span class="c1"># Get neighboring atoms</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span>
            
            <span class="c1"># Check for exactly three neighbors: one C, one H, and one O</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">symbols</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">symbols</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">symbols</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># If conditions are met, append the carbon atom&#39;s index to the list</span>
                    <span class="n">carbons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>

    <span class="c1"># Return the list of carbon atom indices that are part of an aldehyde group</span>
    <span class="k">return</span> <span class="n">carbons</span></div>


<div class="viewcode-block" id="find_beta_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_beta_carbons">[docs]</a><span class="k">def</span> <span class="nf">find_beta_carbons</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies pairs of aldehyde (carbonyl) carbon atoms and their beta carbon atoms in a molecule.</span>

<span class="sd">    This function finds aldehyde carbon atoms (part of a carbonyl group) and identifies the beta carbon atoms </span>
<span class="sd">    that are bonded to them. Beta carbon atoms are those directly bonded to an alpha carbon, which is </span>
<span class="sd">    directly bonded to the aldehyde carbon. The function returns a list of tuples where each tuple contains </span>
<span class="sd">    the index of an aldehyde carbon atom and the index of a corresponding beta carbon atom.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        A SMILES string representing the molecular structure.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of tuples</span>
<span class="sd">        A list of tuples where each tuple contains two integers. The first integer is the index of an aldehyde carbon atom, </span>
<span class="sd">        and the second is the index of a corresponding beta carbon atom that is bonded to at least one hydrogen atom.</span>
<span class="sd">        Atom indices are zero-based and correspond to the order in which atoms appear in the RDKit molecule object.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; find_beta_carbons(&#39;CC(=O)C&#39;)</span>
<span class="sd">    [(1, 0)]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function identifies aldehyde (carbonyl) carbon atoms and traces their alpha and beta carbons.</span>
<span class="sd">    - The beta carbon is selected only if it is bonded to at least one hydrogen atom, ensuring that it is a valid beta carbon.</span>
<span class="sd">    - This function is useful in organic chemistry when looking for specific structural motifs around aldehyde groups.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get indices of aldehyde carbon atoms</span>
    <span class="n">aldehyde_carbons</span> <span class="o">=</span> <span class="n">find_required_aldehyde_carbons</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>

    <span class="c1"># Create a molecule object from SMILES and add hydrogens explicitly</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">))</span>
    
    <span class="c1"># Initialize a list to store pairs of aldehyde and beta carbon atoms</span>
    <span class="n">carbon_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate through each aldehyde carbon atom</span>
    <span class="k">for</span> <span class="n">aldehyde_carbon</span> <span class="ow">in</span> <span class="n">aldehyde_carbons</span><span class="p">:</span>
        <span class="c1"># Find alpha carbon atoms (directly bonded carbon atoms)</span>
        <span class="n">alpha_carbon</span> <span class="o">=</span> <span class="p">[</span><span class="n">neighbor</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">aldehyde_carbon</span><span class="p">)</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">]</span>
        
        <span class="n">all_beta_carbons</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate through each alpha carbon to find beta carbon atoms</span>
        <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">alpha_carbon</span><span class="p">:</span>
            <span class="c1"># Find beta carbon atoms that are bonded to at least one hydrogen atom</span>
            <span class="n">beta_carbons</span> <span class="o">=</span> <span class="p">[</span><span class="n">neighbor</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">())]</span>

            <span class="n">all_beta_carbons</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">beta_carbons</span><span class="p">)</span>

        <span class="c1"># Ensure beta carbon is not the aldehyde carbon itself</span>
        <span class="n">all_beta_carbons</span> <span class="o">=</span> <span class="p">[</span><span class="n">beta</span> <span class="k">for</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">all_beta_carbons</span> <span class="k">if</span> <span class="n">beta</span> <span class="o">!=</span> <span class="n">aldehyde_carbon</span><span class="p">]</span>

        <span class="c1"># Randomly select a beta carbon for pairing if available</span>
        <span class="k">if</span> <span class="n">all_beta_carbons</span><span class="p">:</span>
            <span class="n">chosen_beta_carbon</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">all_beta_carbons</span><span class="p">)</span>
            <span class="n">carbon_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">aldehyde_carbon</span><span class="p">,</span> <span class="n">chosen_beta_carbon</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">carbon_pairs</span></div>

<div class="viewcode-block" id="connect_rings_C3"><a class="viewcode-back" href="../../api/utils.html#coal.utils.connect_rings_C3">[docs]</a><span class="k">def</span> <span class="nf">connect_rings_C3</span><span class="p">(</span><span class="n">smiles1</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connects a given molecule with a propane molecule at identified beta carbon positions.</span>

<span class="sd">    This function takes an initial molecule represented by a SMILES string and connects it to a propane molecule</span>
<span class="sd">    (&#39;CCC&#39;) at the beta carbon positions identified in the initial molecule. If suitable beta carbon atoms </span>
<span class="sd">    (those that are part of aldehyde groups) are found, it adds a propane unit at those positions and returns </span>
<span class="sd">    the modified molecule as a new SMILES string. If no suitable positions are found, it returns None.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles1 : str</span>
<span class="sd">        A SMILES string representing the initial molecule to which propane will be connected.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str or None</span>
<span class="sd">        A SMILES string representing the modified molecule after connection with propane. </span>
<span class="sd">        If no suitable carbon atoms are found for the connection, returns None.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; connect_rings_C3(&#39;CC(=O)C&#39;)</span>
<span class="sd">    &#39;CC(=O)CCC&#39;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function uses the RDKit library to manipulate molecular structures.</span>
<span class="sd">    - The propane molecule is added at the beta carbon positions found in the input molecule.</span>
<span class="sd">    - If no suitable aldehyde carbon atoms (those that can be connected to propane) are found, the function will print </span>
<span class="sd">      a message and return None.</span>
<span class="sd">    - The function assumes that the propane molecule (&#39;CCC&#39;) can be directly connected to the identified positions </span>
<span class="sd">      without additional steric or electronic considerations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smiles2</span> <span class="o">=</span> <span class="s1">&#39;CCC&#39;</span>
    
    <span class="c1"># Convert input SMILES strings to RDKit molecule objects</span>
    <span class="n">mol1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles1</span><span class="p">)</span>
    <span class="n">mol2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles2</span><span class="p">)</span>
    
    <span class="c1"># Find beta carbon positions in the initial molecule</span>
    <span class="n">carbons1_list</span> <span class="o">=</span> <span class="n">find_beta_carbons</span><span class="p">(</span><span class="n">smiles1</span><span class="p">)</span>

    <span class="c1"># If no suitable beta carbon atoms are found, return None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">carbons1_list</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No suitable aldehyde carbon atom found in the molecule&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># For each identified pair of aldehyde and beta carbon atoms, combine molecules</span>
    <span class="k">for</span> <span class="n">chosen_pair1</span> <span class="ow">in</span> <span class="n">carbons1_list</span><span class="p">:</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">CombineMols</span><span class="p">(</span><span class="n">mol1</span><span class="p">,</span> <span class="n">mol2</span><span class="p">)</span>
        <span class="n">edit_combined</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">EditableMol</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span>

        <span class="c1"># Calculate new indices in the combined molecule</span>
        <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">chosen_pair1</span>
        <span class="n">index3</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol1</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">())</span>
        <span class="n">index4</span> <span class="o">=</span> <span class="n">index3</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="c1"># Connect the molecules at the calculated indices</span>
        <span class="n">edit_combined</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index3</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>
        <span class="n">edit_combined</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">index2</span><span class="p">,</span> <span class="n">index4</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>

        <span class="c1"># Update mol1 to the modified molecule</span>
        <span class="n">mol1</span> <span class="o">=</span> <span class="n">edit_combined</span><span class="o">.</span><span class="n">GetMol</span><span class="p">()</span>
        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">mol1</span><span class="p">)</span>

    <span class="c1"># Return the SMILES string for the modified molecule</span>
    <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">mol1</span><span class="p">)</span></div>

<div class="viewcode-block" id="update_smiles_lists"><a class="viewcode-back" href="../../api/utils.html#coal.utils.update_smiles_lists">[docs]</a><span class="k">def</span> <span class="nf">update_smiles_lists</span><span class="p">(</span><span class="n">smiles_list1</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">smiles_list2</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes two lists of SMILES strings: connects propane molecules to the first list&#39;s molecules if specific criteria are met, </span>
<span class="sd">    and then adjusts the second list by removing elements to compensate for the carbons added to the first list.</span>

<span class="sd">    This function iterates through the first list of SMILES (`smiles_list1`) and connects a propane molecule (&#39;CCC&#39;) </span>
<span class="sd">    to the molecules that meet specific criteria (those containing aldehyde carbon atoms). It then calculates the </span>
<span class="sd">    difference in the number of carbon atoms between the original and modified molecules in the first list. </span>
<span class="sd">    Based on this difference, it adjusts the second list (`smiles_list2`) by removing the necessary number of elements </span>
<span class="sd">    to compensate for the added carbons.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles_list1 : list of str</span>
<span class="sd">        The first list of SMILES strings to be potentially modified by connecting propane molecules. </span>
<span class="sd">        Each molecule in this list is checked for the presence of aldehyde carbon atoms and modified if necessary.</span>
<span class="sd">    smiles_list2 : list of str</span>
<span class="sd">        The second list of SMILES strings, from which elements will be removed to compensate for the carbons added to the first list.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of lists or None</span>
<span class="sd">        A tuple containing two lists:</span>
<span class="sd">        - The modified first list with propane molecules connected as applicable.</span>
<span class="sd">        - The adjusted second list with elements removed to compensate for added carbons.</span>
<span class="sd">        </span>
<span class="sd">        If there are not enough elements in the second list to compensate for the added carbons, returns None.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; smiles_list1 = [&#39;CC(=O)C&#39;, &#39;CCC&#39;]</span>
<span class="sd">    &gt;&gt;&gt; smiles_list2 = [&#39;C&#39;, &#39;C&#39;, &#39;C&#39;, &#39;C&#39;, &#39;C&#39;, &#39;C&#39;]</span>
<span class="sd">    &gt;&gt;&gt; update_smiles_lists(smiles_list1, smiles_list2)</span>
<span class="sd">    ([&#39;CC(=O)CCC&#39;, &#39;CCC&#39;], [&#39;C&#39;, &#39;C&#39;, &#39;C&#39;, &#39;C&#39;])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function uses the `connect_rings_C3` and `find_required_aldehyde_carbons` functions to identify which molecules </span>
<span class="sd">      in the first list require modification.</span>
<span class="sd">    - If the second list does not have enough elements to accommodate the added carbons, the function prints an error message </span>
<span class="sd">      and returns `None`.</span>
<span class="sd">    - The function assumes that elements in the second list are simple carbon atoms represented by the SMILES string `&#39;C&#39;`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_smiles_list1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">carbon_diff</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Iterate through the first list and process each molecule</span>
    <span class="k">for</span> <span class="n">smiles</span> <span class="ow">in</span> <span class="n">smiles_list1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">find_required_aldehyde_carbons</span><span class="p">(</span><span class="n">smiles</span><span class="p">):</span>
            <span class="n">new_smiles</span> <span class="o">=</span> <span class="n">connect_rings_C3</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_smiles</span> <span class="o">=</span> <span class="n">smiles</span>
        <span class="n">new_smiles_list1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_smiles</span><span class="p">)</span>

        <span class="c1"># Calculate the change in the number of carbon atoms</span>
        <span class="n">old_carbons</span> <span class="o">=</span> <span class="n">smiles</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">new_carbons</span> <span class="o">=</span> <span class="n">new_smiles</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="n">carbon_diff</span> <span class="o">+=</span> <span class="n">new_carbons</span> <span class="o">-</span> <span class="n">old_carbons</span>

    <span class="c1"># Check if there are enough elements in the second list to compensate for the added carbons</span>
    <span class="k">if</span> <span class="n">carbon_diff</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">smiles_list2</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not enough carbons in the second list to compensate the increase in the first list. Needed: </span><span class="si">{</span><span class="n">carbon_diff</span><span class="si">}</span><span class="s2">, Available: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">smiles_list2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Adjust the second list by removing elements</span>
    <span class="n">new_smiles_list2</span> <span class="o">=</span> <span class="n">smiles_list2</span><span class="p">[</span><span class="n">carbon_diff</span><span class="p">:]</span>
    
    <span class="k">return</span> <span class="n">new_smiles_list1</span><span class="p">,</span> <span class="n">new_smiles_list2</span></div>


<span class="k">def</span> <span class="nf">find_required_carbons</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies carbon atoms in a molecule that are connected to exactly two other carbon (or nitrogen) atoms and one hydrogen atom.</span>
<span class="sd">    </span>
<span class="sd">    This function analyzes the given SMILES string and identifies carbon atoms that satisfy the following conditions:</span>
<span class="sd">    - The carbon atom is connected to exactly two other carbon (or nitrogen) atoms.</span>
<span class="sd">    - The carbon atom is also connected to exactly one hydrogen atom.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        A SMILES string representing the molecular structure to be analyzed. This string should be valid and represent a molecule in which </span>
<span class="sd">        carbon atoms meet the specified connectivity criteria.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of indices corresponding to carbon atoms that meet the specified connectivity criteria within the molecule. </span>
<span class="sd">        Atom indices are zero-based, matching the order in which atoms appear in the RDKit molecule object.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; find_required_carbons(&#39;CC(N)C&#39;)</span>
<span class="sd">    [0]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function uses RDKit to parse the SMILES string and then explicitly adds hydrogens to the molecule for proper analysis.</span>
<span class="sd">    - The function checks each carbon atom in the molecule for connectivity with exactly two other carbons (or nitrogen atoms) </span>
<span class="sd">      and exactly one hydrogen atom. If these conditions are met, the atom&#39;s index is added to the result list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create an RDKit molecule object from the SMILES string and add hydrogens explicitly</span>
    <span class="n">molecule</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">))</span>
    
    <span class="c1"># Initialize a list to store indices of carbon atoms meeting the criteria</span>
    <span class="n">required_carbons</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate over all atoms in the molecule</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="c1"># Check if the atom is a carbon atom</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
            <span class="c1"># Get all neighboring atoms of the current carbon atom</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span>
            
            <span class="c1"># Count the number of carbon (or nitrogen) neighbors</span>
            <span class="n">carbon_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">or</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;N&#39;</span><span class="p">])</span>

            <span class="c1"># Count the number of hydrogen neighbors</span>
            <span class="n">hydrogen_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">])</span>

            <span class="c1"># If the carbon atom is connected to exactly two carbon (or nitrogen) atoms and one hydrogen atom</span>
            <span class="k">if</span> <span class="n">carbon_neighbors</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">hydrogen_neighbors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Add the index of the carbon atom to the list</span>
                <span class="n">required_carbons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>
    
    <span class="c1"># Return the list of indices of carbon atoms meeting the criteria</span>
    <span class="k">return</span> <span class="n">required_carbons</span>

<div class="viewcode-block" id="find_required_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_required_carbons">[docs]</a><span class="k">def</span> <span class="nf">find_required_carbons</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies carbon atoms in a molecule that are connected to exactly two other carbon (or nitrogen) atoms and one hydrogen atom.</span>
<span class="sd">    </span>
<span class="sd">    This function analyzes the given SMILES string and identifies carbon atoms that satisfy the following conditions:</span>
<span class="sd">    - The carbon atom is connected to exactly two other carbon (or nitrogen) atoms.</span>
<span class="sd">    - The carbon atom is also connected to exactly one hydrogen atom.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        A SMILES string representing the molecular structure to be analyzed. This string should be valid and represent a molecule in which </span>
<span class="sd">        carbon atoms meet the specified connectivity criteria.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of indices corresponding to carbon atoms that meet the specified connectivity criteria within the molecule. </span>
<span class="sd">        Atom indices are zero-based, matching the order in which atoms appear in the RDKit molecule object.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; find_required_carbons(&#39;CC(N)C&#39;)</span>
<span class="sd">    [0]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function uses RDKit to parse the SMILES string and then explicitly adds hydrogens to the molecule for proper analysis.</span>
<span class="sd">    - The function checks each carbon atom in the molecule for connectivity with exactly two other carbons (or nitrogen atoms) </span>
<span class="sd">      and exactly one hydrogen atom. If these conditions are met, the atom&#39;s index is added to the result list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create an RDKit molecule object from the SMILES string and add hydrogens explicitly</span>
    <span class="n">molecule</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">))</span>
    
    <span class="c1"># Initialize a list to store indices of carbon atoms meeting the criteria</span>
    <span class="n">required_carbons</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate over all atoms in the molecule</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="c1"># Check if the atom is a carbon atom</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
            <span class="c1"># Get all neighboring atoms of the current carbon atom</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span>
            
            <span class="c1"># Count the number of carbon (or nitrogen) neighbors</span>
            <span class="n">carbon_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">or</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;N&#39;</span><span class="p">])</span>

            <span class="c1"># Count the number of hydrogen neighbors</span>
            <span class="n">hydrogen_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">])</span>

            <span class="c1"># If the carbon atom is connected to exactly two carbon (or nitrogen) atoms and one hydrogen atom</span>
            <span class="k">if</span> <span class="n">carbon_neighbors</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">hydrogen_neighbors</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Add the index of the carbon atom to the list</span>
                <span class="n">required_carbons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>
    
    <span class="c1"># Return the list of indices of carbon atoms meeting the criteria</span>
    <span class="k">return</span> <span class="n">required_carbons</span></div>

<span class="k">def</span> <span class="nf">_connect_ring_C</span><span class="p">(</span><span class="n">mol1</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">,</span> <span class="n">mol2</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">,</span> <span class="n">chosen_pair1</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">chosen_pair2</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connects two molecules using two methane molecules to simulate the addition of methyl groups at specified carbon atoms.</span>

<span class="sd">    This function modifies the input molecules `mol1` and `mol2` by adding two methyl groups (from two methane molecules) at</span>
<span class="sd">    the specified carbon atom positions. The carbon atoms are connected according to the indices in `chosen_pair1` for </span>
<span class="sd">    `mol1` and `chosen_pair2` for `mol2`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol1 : Chem.Mol</span>
<span class="sd">        The first molecule object to be connected. This should be an RDKit molecule.</span>
<span class="sd">    mol2 : Chem.Mol</span>
<span class="sd">        The second molecule object to be connected. This should be an RDKit molecule.</span>
<span class="sd">    chosen_pair1 : tuple</span>
<span class="sd">        A tuple of two integers representing the indices of carbon atoms in `mol1` where the methane groups will be attached.</span>
<span class="sd">    chosen_pair2 : tuple</span>
<span class="sd">        A tuple of two integers representing the indices of carbon atoms in `mol2` where the methane groups will be attached.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Chem.Mol</span>
<span class="sd">        A new RDKit Mol object representing the connected molecule structure. This molecule contains the two original </span>
<span class="sd">        molecules with the addition of two methane groups at the specified positions.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; mol1 = Chem.MolFromSmiles(&#39;CCO&#39;)</span>
<span class="sd">    &gt;&gt;&gt; mol2 = Chem.MolFromSmiles(&#39;CC&#39;)</span>
<span class="sd">    &gt;&gt;&gt; chosen_pair1 = (0, 1)</span>
<span class="sd">    &gt;&gt;&gt; chosen_pair2 = (0, 1)</span>
<span class="sd">    &gt;&gt;&gt; new_mol = _connect_ring_C(mol1, mol2, chosen_pair1, chosen_pair2)</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function uses RDKit&#39;s `CombineMols` to combine the two molecules and add the methane groups.</span>
<span class="sd">    - The `chosen_pair1` and `chosen_pair2` should correspond to valid carbon atom indices in `mol1` and `mol2`.</span>
<span class="sd">    - The new molecule is sanitized after the connection to ensure validity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">methane1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    <span class="n">methane2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
    
    <span class="n">combined_mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">CombineMols</span><span class="p">(</span><span class="n">mol1</span><span class="p">,</span> <span class="n">methane1</span><span class="p">)</span>
    <span class="n">combined_mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">CombineMols</span><span class="p">(</span><span class="n">combined_mol</span><span class="p">,</span> <span class="n">methane2</span><span class="p">)</span>
    <span class="n">edit_mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">EditableMol</span><span class="p">(</span><span class="n">combined_mol</span><span class="p">)</span>
    <span class="n">edit_mol</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">chosen_pair1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol1</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()),</span> <span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>
    <span class="n">edit_mol</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">chosen_pair1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol1</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>

    <span class="n">connected_mol</span> <span class="o">=</span> <span class="n">edit_mol</span><span class="o">.</span><span class="n">GetMol</span><span class="p">()</span>
    <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">connected_mol</span><span class="p">)</span>

    <span class="n">methane1_C_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol1</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">())</span>
    <span class="n">methane2_C_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol1</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">combined_mol2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">CombineMols</span><span class="p">(</span><span class="n">mol2</span><span class="p">,</span> <span class="n">connected_mol</span><span class="p">)</span>
    <span class="n">edit_mol2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">EditableMol</span><span class="p">(</span><span class="n">combined_mol2</span><span class="p">)</span>
    <span class="n">edit_mol2</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">chosen_pair2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol2</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">())</span> <span class="o">+</span> <span class="n">methane1_C_index</span><span class="p">,</span> <span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>
    <span class="n">edit_mol2</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">chosen_pair2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol2</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">())</span> <span class="o">+</span> <span class="n">methane2_C_index</span><span class="p">,</span> <span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>

    <span class="n">final_connected_mol</span> <span class="o">=</span> <span class="n">edit_mol2</span><span class="o">.</span><span class="n">GetMol</span><span class="p">()</span>
    <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">final_connected_mol</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_connected_mol</span>

<span class="k">def</span> <span class="nf">_find_index_pairs</span><span class="p">(</span><span class="n">carbons</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">mol</span><span class="p">:</span> <span class="n">Chem</span><span class="o">.</span><span class="n">Mol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds index pairs of carbon atoms within a molecule that are suitable for connection.</span>

<span class="sd">    This function takes a list of carbon atom indices and identifies pairs of carbon atoms </span>
<span class="sd">    within the molecule that are neighbors. The index pairs are returned in a list of tuples, </span>
<span class="sd">    where each tuple represents a unique pair of carbon atoms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    carbons : list of int</span>
<span class="sd">        A list containing indices of carbon atoms within the molecule that are suitable for connection. </span>
<span class="sd">        These indices should correspond to atoms in the `mol` molecule.</span>
<span class="sd">    mol : Chem.Mol</span>
<span class="sd">        The RDKit Mol object representing the molecule in which the carbon atoms are located. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of tuples</span>
<span class="sd">        A list of tuples where each tuple contains two integers. Each integer represents an index of a </span>
<span class="sd">        carbon atom that is connected to another carbon atom in the molecule. The indices are zero-based and </span>
<span class="sd">        correspond to the order in which atoms appear in the RDKit molecule object. </span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; carbons = [0, 2, 4]</span>
<span class="sd">    &gt;&gt;&gt; mol = Chem.MolFromSmiles(&#39;CCOCC&#39;)</span>
<span class="sd">    &gt;&gt;&gt; index_pairs = _find_index_pairs(carbons, mol)</span>
<span class="sd">    &gt;&gt;&gt; print(index_pairs)</span>
<span class="sd">    [(0, 2), (2, 4)]</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function ensures that each pair of carbon atoms is returned only once, </span>
<span class="sd">      i.e., it avoids returning the same pair in reverse order (e.g., (0, 2) and (2, 0)).</span>
<span class="sd">    - The function assumes that the list `carbons` only contains valid indices that refer to carbon atoms </span>
<span class="sd">      within the provided molecule.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">carbons</span><span class="p">:</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="ow">in</span> <span class="n">carbons</span><span class="p">:</span>
                <span class="n">neighbor_idx</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">neighbor_idx</span><span class="p">:</span>  <span class="c1"># Avoid repeating the same pair in reverse order</span>
                    <span class="n">index_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">neighbor_idx</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">index_pairs</span>

<span class="k">def</span> <span class="nf">connect_rings</span><span class="p">(</span><span class="n">molecules_tuple_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connects two rings from a list of molecule tuples by adding two methane groups between them.</span>

<span class="sd">    This function takes a list of molecule tuples, where each tuple contains a SMILES string </span>
<span class="sd">    representing a molecule and a list of indices of carbon atoms that can be used for connection.</span>
<span class="sd">    It selects one pair of carbon atoms from each molecule and connects them by adding two methane </span>
<span class="sd">    groups at the chosen positions. The final connected molecule is then returned as a SMILES string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    molecules_tuple_list : list of tuples</span>
<span class="sd">        A list where each tuple contains:</span>
<span class="sd">        - A SMILES string representing a molecule.</span>
<span class="sd">        - A list of integers, where each integer is an index of a carbon atom that is available for connection.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        A new SMILES string representing the connected molecule structure. If the input list is invalid (less than 2 molecules),</span>
<span class="sd">        an error message is returned instead.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; molecules = [(&#39;C1CCCC1&#39;, [0, 1, 2, 3, 4]), (&#39;C1CCCCC1&#39;, [0, 1, 2, 3, 4, 5])]</span>
<span class="sd">    &gt;&gt;&gt; connect_rings(molecules)</span>
<span class="sd">    &#39;CC1CC(C)C(C)C1&#39;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function selects a pair of carbon atoms from each molecule and connects them by adding two methane groups between them.</span>
<span class="sd">    - The function relies on the `_find_index_pairs` and `_connect_ring_C` functions for finding suitable carbon pairs and connecting the molecules.</span>
<span class="sd">    - If there is less than two molecules in the input list, an appropriate message is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">molecules_tuple_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># If there is only one tuple in the list, return the SMILES string of that tuple</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">molecules_tuple_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">molecules_tuple_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># If the list is empty or contains fewer than 2 molecules, return an error message</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid input: </span><span class="si">{</span><span class="n">molecules_tuple_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;Invalid input. The list must contain at least two molecules.&quot;</span>

    <span class="n">smiles1</span><span class="p">,</span> <span class="n">carbons1</span> <span class="o">=</span> <span class="n">molecules_tuple_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">smiles2</span><span class="p">,</span> <span class="n">carbons2</span> <span class="o">=</span> <span class="n">molecules_tuple_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">mol1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles1</span><span class="p">)</span>
    <span class="n">mol2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles2</span><span class="p">)</span>

    <span class="n">index_pairs_carbons1</span> <span class="o">=</span> <span class="n">_find_index_pairs</span><span class="p">(</span><span class="n">carbons1</span><span class="p">,</span> <span class="n">mol1</span><span class="p">)</span>
    <span class="n">index_pairs_carbons2</span> <span class="o">=</span> <span class="n">_find_index_pairs</span><span class="p">(</span><span class="n">carbons2</span><span class="p">,</span> <span class="n">mol2</span><span class="p">)</span>

    <span class="n">chosen_pair1</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">index_pairs_carbons1</span><span class="p">)</span>
    <span class="n">chosen_pair2</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">index_pairs_carbons2</span><span class="p">)</span>

    <span class="c1"># Call the helper function to connect the molecules with methane</span>
    <span class="n">final_connected_mol</span> <span class="o">=</span> <span class="n">_connect_ring_C</span><span class="p">(</span><span class="n">mol1</span><span class="p">,</span> <span class="n">mol2</span><span class="p">,</span> <span class="n">chosen_pair1</span><span class="p">,</span> <span class="n">chosen_pair2</span><span class="p">)</span>

    <span class="n">final_connected_smiles</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">final_connected_mol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">final_connected_smiles</span>

<div class="viewcode-block" id="connect_rings"><a class="viewcode-back" href="../../api/utils.html#coal.utils.connect_rings">[docs]</a><span class="k">def</span> <span class="nf">connect_rings</span><span class="p">(</span><span class="n">molecules_tuple_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connects two rings from a list of molecule tuples by adding two methane groups between them.</span>

<span class="sd">    This function takes a list of molecule tuples, where each tuple contains a SMILES string </span>
<span class="sd">    representing a molecule and a list of indices of carbon atoms that can be used for connection.</span>
<span class="sd">    It selects one pair of carbon atoms from each molecule and connects them by adding two methane </span>
<span class="sd">    groups at the chosen positions. The final connected molecule is then returned as a SMILES string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    molecules_tuple_list : list of tuples</span>
<span class="sd">        A list where each tuple contains:</span>
<span class="sd">        - A SMILES string representing a molecule.</span>
<span class="sd">        - A list of integers, where each integer is an index of a carbon atom that is available for connection.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        A new SMILES string representing the connected molecule structure. If the input list is invalid (less than 2 molecules),</span>
<span class="sd">        an error message is returned instead.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; molecules = [(&#39;C1CCCC1&#39;, [0, 1, 2, 3, 4]), (&#39;C1CCCCC1&#39;, [0, 1, 2, 3, 4, 5])]</span>
<span class="sd">    &gt;&gt;&gt; connect_rings(molecules)</span>
<span class="sd">    &#39;CC1CC(C)C(C)C1&#39;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function selects a pair of carbon atoms from each molecule and connects them by adding two methane groups between them.</span>
<span class="sd">    - The function relies on the `_find_index_pairs` and `_connect_ring_C` functions for finding suitable carbon pairs and connecting the molecules.</span>
<span class="sd">    - If there is less than two molecules in the input list, an appropriate message is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">molecules_tuple_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># If there is only one tuple in the list, return the SMILES string of that tuple</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">molecules_tuple_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">molecules_tuple_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># If the list is empty or contains fewer than 2 molecules, return an error message</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid input: </span><span class="si">{</span><span class="n">molecules_tuple_list</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;Invalid input. The list must contain at least two molecules.&quot;</span>

    <span class="n">smiles1</span><span class="p">,</span> <span class="n">carbons1</span> <span class="o">=</span> <span class="n">molecules_tuple_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">smiles2</span><span class="p">,</span> <span class="n">carbons2</span> <span class="o">=</span> <span class="n">molecules_tuple_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">mol1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles1</span><span class="p">)</span>
    <span class="n">mol2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles2</span><span class="p">)</span>

    <span class="n">index_pairs_carbons1</span> <span class="o">=</span> <span class="n">_find_index_pairs</span><span class="p">(</span><span class="n">carbons1</span><span class="p">,</span> <span class="n">mol1</span><span class="p">)</span>
    <span class="n">index_pairs_carbons2</span> <span class="o">=</span> <span class="n">_find_index_pairs</span><span class="p">(</span><span class="n">carbons2</span><span class="p">,</span> <span class="n">mol2</span><span class="p">)</span>

    <span class="n">chosen_pair1</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">index_pairs_carbons1</span><span class="p">)</span>
    <span class="n">chosen_pair2</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">index_pairs_carbons2</span><span class="p">)</span>

    <span class="c1"># Call the helper function to connect the molecules with methane</span>
    <span class="n">final_connected_mol</span> <span class="o">=</span> <span class="n">_connect_ring_C</span><span class="p">(</span><span class="n">mol1</span><span class="p">,</span> <span class="n">mol2</span><span class="p">,</span> <span class="n">chosen_pair1</span><span class="p">,</span> <span class="n">chosen_pair2</span><span class="p">)</span>

    <span class="n">final_connected_smiles</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">final_connected_mol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">final_connected_smiles</span></div>

<div class="viewcode-block" id="count_ketone_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.count_ketone_carbons">[docs]</a><span class="k">def</span> <span class="nf">count_ketone_carbons</span><span class="p">(</span><span class="n">smiles_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts the total number of ketone carbon atoms in a list of molecules represented by SMILES strings.</span>

<span class="sd">    A ketone carbon atom is defined as a carbon atom that is double-bonded to an oxygen atom and is not part of an aldehyde or carboxyl group.</span>

<span class="sd">    This function iterates over the provided list of SMILES strings, converts each molecule to an RDKit molecule object, </span>
<span class="sd">    adds explicit hydrogen atoms to the molecule structure (if not already present), and identifies carbon atoms that are </span>
<span class="sd">    part of ketone functional groups. The total count of such carbon atoms is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles_list : list of str</span>
<span class="sd">        A list containing SMILES strings of the molecules to analyze. Each string represents a molecule.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    total_count : int</span>
<span class="sd">        The total count of ketone carbon atoms across all molecules in the given list. </span>
<span class="sd">        A ketone carbon is a carbon atom double-bonded to an oxygen atom.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; smiles = [&#39;CC(=O)C&#39;, &#39;C1CC(=O)C1&#39;, &#39;CC(C(=O)C)C&#39;]</span>
<span class="sd">    &gt;&gt;&gt; count_ketone_carbons(smiles)</span>
<span class="sd">    3</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function uses RDKit to parse the SMILES strings and explicitly adds hydrogen atoms to the molecule to ensure </span>
<span class="sd">      the bonds are correctly interpreted.</span>
<span class="sd">    - Ketone carbons are identified based on the presence of a double bond between a carbon atom and an oxygen atom.</span>
<span class="sd">    - This function does not distinguish between ketones and other carbonyl compounds (such as aldehydes or carboxylic acids) </span>
<span class="sd">      because it looks for a carbon double-bonded to an oxygen atom without further specificity.</span>
<span class="sd">    - This function is useful for counting ketone functional groups in molecules.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">smiles</span> <span class="ow">in</span> <span class="n">smiles_list</span><span class="p">:</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
        <span class="n">mol_with_hs</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>  <span class="c1"># Add hydrogens explicitly.</span>

        <span class="n">ketone_carbons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol_with_hs</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span>
                <span class="n">has_double_bonded_oxygen</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                    <span class="c1"># Check for a double bond between the carbon and an oxygen atom.</span>
                    <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span> <span class="ow">and</span> <span class="n">mol_with_hs</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">(),</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="o">==</span> <span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">:</span>
                        <span class="n">has_double_bonded_oxygen</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">has_double_bonded_oxygen</span><span class="p">:</span>
                    <span class="n">ketone_carbons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>  <span class="c1"># Add the index of the ketone carbon atom.</span>
        <span class="n">total_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ketone_carbons</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">total_count</span></div>

<div class="viewcode-block" id="find_C4_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_C4_carbons">[docs]</a><span class="k">def</span> <span class="nf">find_C4_carbons</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies carbon atoms in a molecule that are bonded to exactly two carbon or nitrogen atoms </span>
<span class="sd">    and have one or two hydrogen atoms.</span>

<span class="sd">    The function iterates over the atoms in the molecule, checks if a carbon atom meets the bonding </span>
<span class="sd">    criteria (bonded to two carbon or nitrogen atoms and one or two hydrogen atoms), and returns </span>
<span class="sd">    a list of the indices of such carbon atoms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        A SMILES string representing the molecular structure to be analyzed. </span>
<span class="sd">        The string encodes the connectivity of atoms and bonds within the molecule.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of indices corresponding to carbon atoms that meet the specified bonding criteria </span>
<span class="sd">        within the molecule. Atom indices are zero-based, corresponding to the order in which atoms </span>
<span class="sd">        appear in the RDKit molecule object.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; smiles = &#39;CC(C)C&#39;</span>
<span class="sd">    &gt;&gt;&gt; find_C4_carbons(smiles)</span>
<span class="sd">    [1, 2]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function uses RDKit to convert the SMILES string into a molecule object and explicitly </span>
<span class="sd">      adds hydrogen atoms to ensure accurate bond interpretation.</span>
<span class="sd">    - The criteria for selecting carbon atoms are:</span>
<span class="sd">        1. The atom must be bonded to exactly two carbon or nitrogen atoms.</span>
<span class="sd">        2. The atom must have one or two hydrogen atoms bonded to it.</span>
<span class="sd">    - This function is useful for identifying specific carbon atoms that fit certain structural </span>
<span class="sd">      patterns, such as those in substituted hydrocarbons or nitrogen-containing compounds.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">molecule</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">))</span>  <span class="c1"># Convert SMILES to molecule and explicitly add hydrogens.</span>

    <span class="n">required_carbons</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Initialize a list to store indices of carbon atoms meeting the criteria.</span>

    <span class="c1"># Iterate through all atoms in the molecule.</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>  <span class="c1"># Check if the atom is a carbon atom.</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span>  <span class="c1"># Get all neighboring atoms.</span>

            <span class="c1"># Count carbon and nitrogen neighbors.</span>
            <span class="n">carbon_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">]])</span>

            <span class="c1"># Count hydrogen neighbors.</span>
            <span class="n">hydrogen_neighbors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">])</span>

            <span class="c1"># Check if the carbon atom meets the specified bonding criteria.</span>
            <span class="k">if</span> <span class="n">carbon_neighbors</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">hydrogen_neighbors</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">hydrogen_neighbors</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">required_carbons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>  <span class="c1"># Add the carbon atom&#39;s index to the list.</span>

    <span class="k">return</span> <span class="n">required_carbons</span>  <span class="c1"># Return the list of indices of carbon atoms meeting the criteria.</span></div>

<div class="viewcode-block" id="connect_rings_C4"><a class="viewcode-back" href="../../api/utils.html#coal.utils.connect_rings_C4">[docs]</a><span class="k">def</span> <span class="nf">connect_rings_C4</span><span class="p">(</span><span class="n">smiles1</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connects a given molecule with a butane molecule at specified carbon atom positions.</span>

<span class="sd">    This function finds carbon atoms in the input molecule (represented by its SMILES string) </span>
<span class="sd">    that meet the criteria for connecting to a butane molecule at its terminal carbons. </span>
<span class="sd">    If suitable carbon atoms are found, the butane molecule is connected, and the resulting </span>
<span class="sd">    molecule is returned as a SMILES string. If no suitable carbon atoms are found, </span>
<span class="sd">    it returns None.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles1 : str</span>
<span class="sd">        A SMILES string representing the initial molecule to which butane will be connected. </span>
<span class="sd">        The function will attempt to identify specific carbon atoms in this molecule for the connection.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str or None</span>
<span class="sd">        A SMILES string representing the modified molecule after connecting with butane. </span>
<span class="sd">        If no suitable carbon atoms are found for the connection, returns None.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; smiles1 = &#39;CC(C)C&#39;</span>
<span class="sd">    &gt;&gt;&gt; connect_rings_C4(smiles1)</span>
<span class="sd">    &#39;CC(C)CCCC&#39;  # Example output, depending on the initial molecule</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function uses the `find_C4_carbons` function to identify potential carbon atoms in the </span>
<span class="sd">      input molecule that are suitable for bonding with butane. These atoms must meet specific </span>
<span class="sd">      bonding criteria (bonded to two carbons or nitrogens and one or two hydrogens).</span>
<span class="sd">    - The function attempts to connect the molecule to butane (a four-carbon chain, SMILES: &#39;CCCC&#39;).</span>
<span class="sd">    - The connection is made by bonding the terminal carbons of butane to two carbon atoms from </span>
<span class="sd">      the original molecule.</span>
<span class="sd">    - If no suitable pair of carbon atoms for bonding is found, the function prints a message </span>
<span class="sd">      and returns None.</span>
<span class="sd">    - The function utilizes RDKit to perform molecule manipulation and bonding.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smiles2</span> <span class="o">=</span> <span class="s1">&#39;CCCC&#39;</span>  <span class="c1"># SMILES representation of butane</span>
    <span class="n">carbons2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># Butane&#39;s terminal carbon indices (illustrative, not used directly)</span>

    <span class="c1"># Find suitable C4 carbons in the first molecule</span>
    <span class="n">carbons1</span> <span class="o">=</span> <span class="n">find_C4_carbons</span><span class="p">(</span><span class="n">smiles1</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">carbons1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No suitable carbon atom found in the molecule&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">mol1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles1</span><span class="p">)</span>
    <span class="n">mol2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles2</span><span class="p">)</span>

    <span class="c1"># Identify adjacent carbon pairs in the first molecule for connection</span>
    <span class="n">index_pairs_carbons1</span> <span class="o">=</span> <span class="n">_find_adjacent_pairs</span><span class="p">(</span><span class="n">carbons1</span><span class="p">,</span> <span class="n">mol1</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">index_pairs_carbons1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No suitable pair of carbon atoms found in the molecule: </span><span class="si">{</span><span class="n">smiles1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Randomly choose a pair of carbon atoms to connect with butane</span>
    <span class="n">chosen_pair1</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">index_pairs_carbons1</span><span class="p">)</span>

    <span class="c1"># Combine the two molecules: the initial molecule and butane</span>
    <span class="n">combined</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">CombineMols</span><span class="p">(</span><span class="n">mol1</span><span class="p">,</span> <span class="n">mol2</span><span class="p">)</span>
    <span class="n">edit_combined</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">EditableMol</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span>

    <span class="c1"># Recalculate the atom indices in the combined molecule</span>
    <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">chosen_pair1</span>  <span class="c1"># Indices for carbons in mol1</span>
    <span class="n">index3</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol1</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">())</span>  <span class="c1"># Index for the first atom of mol2 (butane)</span>
    <span class="n">index4</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol1</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">())</span> <span class="o">+</span> <span class="mi">3</span>  <span class="c1"># Index for the last atom of mol2 (butane)</span>

    <span class="c1"># Add bonds between the selected carbons from mol1 and butane&#39;s terminal carbons</span>
    <span class="n">edit_combined</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">index3</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>
    <span class="n">edit_combined</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">index2</span><span class="p">,</span> <span class="n">index4</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>

    <span class="c1"># Get the final connected molecule and sanitize it</span>
    <span class="n">connected_mol</span> <span class="o">=</span> <span class="n">edit_combined</span><span class="o">.</span><span class="n">GetMol</span><span class="p">()</span>
    <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">connected_mol</span><span class="p">)</span>

    <span class="c1"># Return the SMILES string of the connected molecule</span>
    <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">connected_mol</span><span class="p">)</span></div>

<div class="viewcode-block" id="repeat_connect_rings_C4"><a class="viewcode-back" href="../../api/utils.html#coal.utils.repeat_connect_rings_C4">[docs]</a><span class="k">def</span> <span class="nf">repeat_connect_rings_C4</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">num_repeats</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iteratively connects a butane molecule to the given molecule a specified number of times.</span>

<span class="sd">    This function uses the `connect_rings_C4` function to iteratively connect a butane molecule </span>
<span class="sd">    to the provided molecule. The connection is repeated for the given number of times, or until </span>
<span class="sd">    no suitable carbon atoms for connection are found.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        A SMILES string representing the initial molecule to be modified. The function will attempt </span>
<span class="sd">        to connect butane molecules to it in the specified number of iterations.</span>

<span class="sd">    num_repeats : int</span>
<span class="sd">        The number of times the butane molecule should be connected to the initial molecule. </span>
<span class="sd">        Each iteration will attempt to connect another butane molecule.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The SMILES string representing the modified molecule after all connections have been made. </span>
<span class="sd">        If at any point the connection cannot be made (e.g., no suitable carbons are found), the function </span>
<span class="sd">        returns the most recent successful modification or the original molecule if no modifications were made.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; repeat_connect_rings_C4(&quot;CC(C)C&quot;, 3)</span>
<span class="sd">    &#39;CC(C)CCCCCCCCCCCC&#39;  # Example output after 3 iterations of connecting butane.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function makes use of `connect_rings_C4` to handle the actual connection of butane molecules.</span>
<span class="sd">    - If no suitable carbon atoms for bonding are found in any iteration, the function terminates early.</span>
<span class="sd">    - The molecule is modified by repeatedly connecting butane molecules, and the result is returned as a SMILES string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_repeats</span><span class="p">):</span>
        <span class="n">new_smiles</span> <span class="o">=</span> <span class="n">connect_rings_C4</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_smiles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>  <span class="c1"># Stop if no suitable carbon atom found or connection failed</span>
        <span class="n">smiles</span> <span class="o">=</span> <span class="n">new_smiles</span>
    <span class="k">return</span> <span class="n">smiles</span></div>

<div class="viewcode-block" id="process_smiles"><a class="viewcode-back" href="../../api/utils.html#coal.utils.process_smiles">[docs]</a><span class="k">def</span> <span class="nf">process_smiles</span><span class="p">(</span><span class="n">smiles_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorts a list of SMILES strings in a zigzag pattern based on the sum of atomic numbers in each molecule.</span>

<span class="sd">    This function sorts a list of SMILES strings by the sum of the atomic numbers of the atoms in the molecule.</span>
<span class="sd">    The sorted list is then arranged in a zigzag pattern: the highest sum atomic number is placed at the first </span>
<span class="sd">    position, the second highest at the second position, and so on, alternating between the highest and lowest </span>
<span class="sd">    sums.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles_list : list of str</span>
<span class="sd">        A list containing SMILES strings of the molecules to analyze. The molecules will be sorted </span>
<span class="sd">        based on the sum of atomic numbers of their constituent atoms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of str</span>
<span class="sd">        A list of SMILES strings sorted in a zigzag pattern based on the sum of atomic numbers </span>
<span class="sd">        in each molecule. The list is arranged such that the highest sums are placed at even indices and </span>
<span class="sd">        the lowest sums at odd indices.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; smiles_list = [&#39;CCO&#39;, &#39;CC(C)C&#39;, &#39;CCCC&#39;]</span>
<span class="sd">    &gt;&gt;&gt; process_smiles(smiles_list)</span>
<span class="sd">    [&#39;CC(C)C&#39;, &#39;CCCC&#39;, &#39;CCO&#39;]  # Example output showing zigzag sorted order</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The sum of atomic numbers is calculated for each molecule by summing the atomic numbers of all atoms </span>
<span class="sd">      in the molecule.</span>
<span class="sd">    - The zigzag pattern alternates between the highest and lowest sums, placing the highest sums in even positions </span>
<span class="sd">      (0-based index) and the lowest sums in odd positions.</span>
<span class="sd">    - The sorting ensures that the list is not simply sorted by atomic number sums in ascending or descending order, </span>
<span class="sd">      but rather in a unique &quot;zigzag&quot; pattern.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Inline function to count atomic numbers in a molecule</span>
    <span class="k">def</span> <span class="nf">count_atoms_inline</span><span class="p">(</span><span class="n">smiles</span><span class="p">):</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetAtomicNum</span><span class="p">()</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">())</span>

    <span class="c1"># Sort the SMILES strings based on their atomic numbers</span>
    <span class="n">sorted_items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">smiles_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">count_atoms_inline</span><span class="p">)</span>
    
    <span class="c1"># Initialize the result list with None to match the input list&#39;s length</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">smiles_list</span><span class="p">)</span>
    
    <span class="c1"># Apply the zigzag sorting logic</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_items</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_items</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_items</span><span class="p">[</span><span class="n">end</span><span class="p">]</span>
            <span class="n">end</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_items</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="find_aldehyde_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_aldehyde_carbons">[docs]</a><span class="k">def</span> <span class="nf">find_aldehyde_carbons</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">rdchem</span><span class="o">.</span><span class="n">Mol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies aldehyde carbon atoms within a given molecule.</span>

<span class="sd">    An aldehyde group consists of a carbonyl group (C=O) where the carbon is bonded to a hydrogen atom (–CHO).</span>
<span class="sd">    This function checks for carbon atoms that are part of such a group by looking for a carbon </span>
<span class="sd">    bonded to one oxygen atom with a double bond and one hydrogen atom.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol : rdkit.Chem.Mol</span>
<span class="sd">        The RDKit molecule object to be analyzed. This molecule will be checked for aldehyde groups.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    aldehyde_carbons : list</span>
<span class="sd">        A list of indices corresponding to carbon atoms that are part of an aldehyde group within the molecule.</span>
<span class="sd">        Atom indices are zero-based, matching the order in which atoms appear in the RDKit molecule object.</span>
<span class="sd">        If no aldehyde groups are found, the list will be empty.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; mol = Chem.MolFromSmiles(&quot;CC(C)C=O&quot;)</span>
<span class="sd">    &gt;&gt;&gt; find_aldehyde_carbons(mol)</span>
<span class="sd">    [4]  # The carbon in the aldehyde group is at index 4.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function explicitly adds hydrogen atoms to the molecule for more accurate analysis of aldehyde groups.</span>
<span class="sd">    - The function checks for a carbon atom bonded to one oxygen atom (double bond) and one hydrogen atom, </span>
<span class="sd">      indicative of an aldehyde group.</span>
<span class="sd">    - Only carbon atoms that meet these criteria are included in the result list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mol_with_hs</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>  <span class="c1"># Explicitly add all hydrogens to the molecule for accurate analysis</span>

    <span class="n">aldehyde_carbons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol_with_hs</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
            <span class="n">oxygen_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">]</span>
            <span class="n">hydrogen_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">]</span>
            
            <span class="c1"># Check for one oxygen neighbor, one hydrogen neighbor, and the presence of a double bond with oxygen</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">oxygen_neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">hydrogen_neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetOtherAtom</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span> <span class="ow">and</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="o">==</span> <span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">:</span>
                        <span class="n">aldehyde_carbons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>
                        <span class="k">break</span>  <span class="c1"># Once an aldehyde group is confirmed, no need to check other bonds of the same carbon</span>

    <span class="k">return</span> <span class="n">aldehyde_carbons</span></div>

<div class="viewcode-block" id="find_hydroxy_oxygen"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_hydroxy_oxygen">[docs]</a><span class="k">def</span> <span class="nf">find_hydroxy_oxygen</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">rdchem</span><span class="o">.</span><span class="n">Mol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies the indices of hydroxy oxygen and sulfur atoms in a given RDKit molecule object.</span>

<span class="sd">    Hydroxy oxygen atoms are defined as oxygen atoms bonded to at least one hydrogen atom (–OH), </span>
<span class="sd">    and sulfur atoms are defined as sulfur atoms bonded to at least one hydrogen atom (–SH), indicating </span>
<span class="sd">    the presence of alcohol or thiol groups.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol : rdkit.Chem.Mol</span>
<span class="sd">        An RDKit molecule object to be analyzed. This molecule will be checked for hydroxy oxygen and sulfur atoms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hydroxy_atoms : list</span>
<span class="sd">        A list of indices for oxygen and sulfur atoms bonded to at least one hydrogen atom,</span>
<span class="sd">        indicating the presence of hydroxy or thiol groups respectively. </span>
<span class="sd">        Atom indices are zero-based, matching the order in which atoms appear in the RDKit molecule object.</span>
<span class="sd">        If no hydroxy or thiol atoms are found, the list will be empty.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; mol = Chem.MolFromSmiles(&quot;CC(C)O&quot;)</span>
<span class="sd">    &gt;&gt;&gt; find_hydroxy_oxygen(mol)</span>
<span class="sd">    [4]  # The oxygen atom in the hydroxy group is at index 4.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function explicitly adds hydrogen atoms to the molecule for more accurate analysis of hydroxy and thiol groups.</span>
<span class="sd">    - Only oxygen and sulfur atoms that are bonded to at least one hydrogen atom are included in the result list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mol_with_hs</span> <span class="o">=</span> <span class="n">AddHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>  <span class="c1"># Add explicit hydrogens to the molecule for accurate analysis.</span>

    <span class="n">hydroxy_atoms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol_with_hs</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">]:</span>  <span class="c1"># Check for oxygen and sulfur atoms.</span>
            <span class="c1"># Check if the atom is bonded to a hydrogen atom.</span>
            <span class="n">has_hydrogen</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">has_hydrogen</span><span class="p">:</span>
                <span class="n">hydroxy_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>  <span class="c1"># Append the index of the hydroxy atom.</span>

    <span class="k">return</span> <span class="n">hydroxy_atoms</span></div>

<div class="viewcode-block" id="find_ketone_alpha_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_ketone_alpha_carbons">[docs]</a><span class="k">def</span> <span class="nf">find_ketone_alpha_carbons</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">rdchem</span><span class="o">.</span><span class="n">Mol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies alpha carbon atoms adjacent to carbonyl carbons in ketones within a given molecule.</span>

<span class="sd">    Alpha carbon atoms are defined as those that are adjacent to the carbonyl group (C=O) in ketones.</span>
<span class="sd">    These are typically the carbons bonded to the carbonyl carbon but not directly bonded to the oxygen atom.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol : rdkit.Chem.Mol</span>
<span class="sd">        An RDKit molecule object representing the molecule to be analyzed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ketone_alpha_carbons : list</span>
<span class="sd">        A list of indices for alpha carbon atoms that are adjacent to carbonyl carbons in ketones.</span>
<span class="sd">        The atom indices are zero-based, corresponding to the order in which atoms appear in the RDKit molecule object.</span>
<span class="sd">        If no alpha carbons are found, the list will be empty.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; mol = Chem.MolFromSmiles(&quot;CC(=O)C&quot;)</span>
<span class="sd">    &gt;&gt;&gt; find_ketone_alpha_carbons(mol)</span>
<span class="sd">    [1]  # The alpha carbon adjacent to the carbonyl group at index 1.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function identifies ketones by finding oxygen atoms bonded to a carbonyl carbon.</span>
<span class="sd">    - It assumes that the carbonyl group has a double bond between the oxygen and carbon.</span>
<span class="sd">    - The alpha carbon is defined as a carbon atom bonded to the carbonyl carbon but not to the oxygen atom.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ketone_alpha_carbons</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetTotalNumHs</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Check for oxygen atoms not bonded to any hydrogens</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span>
                <span class="n">non_H_neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;H&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_H_neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">carbonyl_carbon</span> <span class="o">=</span> <span class="n">non_H_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># Ensure the bond between oxygen and the carbonyl carbon is a double bond</span>
                    <span class="k">if</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetBondBetweenAtoms</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">(),</span> <span class="n">carbonyl_carbon</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="o">==</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">:</span>
                        <span class="c1"># Now find the alpha carbons: those bonded to the carbonyl carbon, excluding the oxygen itself</span>
                        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">carbonyl_carbon</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">and</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="o">!=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">():</span>
                                <span class="n">ketone_alpha_carbons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">ketone_alpha_carbons</span></div>

<div class="viewcode-block" id="find_alpha_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_alpha_carbons">[docs]</a><span class="k">def</span> <span class="nf">find_alpha_carbons</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">rdchem</span><span class="o">.</span><span class="n">Mol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies indices of non-aromatic alpha carbon atoms that are directly bonded to aromatic carbon atoms.</span>

<span class="sd">    Alpha carbon atoms are defined as carbon atoms that are directly bonded to an aromatic carbon atom, </span>
<span class="sd">    but are themselves not aromatic. These are typically carbons attached to aromatic rings in compounds </span>
<span class="sd">    like aryl groups attached to alkyl chains.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol : rdkit.Chem.Mol</span>
<span class="sd">        An RDKit molecule object representing the molecule to be analyzed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of unique indices for non-aromatic alpha carbon atoms that are directly bonded to aromatic carbon atoms.</span>
<span class="sd">        Atom indices are zero-based, corresponding to the order in which atoms appear in the RDKit molecule object.</span>
<span class="sd">        If no such alpha carbons are found, the list will be empty.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; mol = Chem.MolFromSmiles(&quot;CC1=CC=CC=C1&quot;)</span>
<span class="sd">    &gt;&gt;&gt; find_alpha_carbons(mol)</span>
<span class="sd">    [0, 3]  # The alpha carbons bonded to the aromatic ring at indices 0 and 3.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function identifies non-aromatic carbons bonded to aromatic carbons in molecules with aromatic rings.</span>
<span class="sd">    - The search excludes aromatic carbons, focusing only on non-aromatic carbons.</span>
<span class="sd">    - The set data structure is used to avoid duplicate indices for alpha carbons.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alpha_carbons</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Use a set to avoid duplicate indices</span>

    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">():</span>
                    <span class="n">alpha_carbons</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>  <span class="c1"># Add unique alpha carbon indices</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">alpha_carbons</span><span class="p">)</span>  <span class="c1"># Convert back to list for consistency with expected return type</span></div>

<div class="viewcode-block" id="find_aliphatic_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_aliphatic_carbons">[docs]</a><span class="k">def</span> <span class="nf">find_aliphatic_carbons</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">rdchem</span><span class="o">.</span><span class="n">Mol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies indices of aliphatic (non-aromatic) carbon atoms within a given molecule.</span>

<span class="sd">    Aliphatic carbon atoms are defined as carbon atoms that are not part of an aromatic ring. These include </span>
<span class="sd">    carbon atoms in chains, branches, or rings that are not aromatic.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol : rdkit.Chem.Mol</span>
<span class="sd">        An RDKit molecule object representing the molecule to be analyzed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of indices corresponding to aliphatic carbon atoms in the molecule.</span>
<span class="sd">        Atom indices are zero-based, corresponding to the order in which atoms appear in the RDKit molecule object.</span>
<span class="sd">        If no aliphatic carbon atoms are found, the list will be empty.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; mol = Chem.MolFromSmiles(&quot;CC1=CC=CC=C1&quot;)</span>
<span class="sd">    &gt;&gt;&gt; find_aliphatic_carbons(mol)</span>
<span class="sd">    [0, 1, 2, 3]  # The aliphatic carbons are the ones in the alkyl chain attached to the aromatic ring.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function identifies carbon atoms that are not part of any aromatic ring in the molecule.</span>
<span class="sd">    - Aliphatic carbons can be in straight chains, branched chains, or non-aromatic rings.</span>
<span class="sd">    - Aromatic carbons, which are part of rings with alternating single and double bonds (like benzene), are excluded.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">aliphatic_carbons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">():</span>
            <span class="n">aliphatic_carbons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>  <span class="c1"># Add the index of each aliphatic carbon atom</span>

    <span class="k">return</span> <span class="n">aliphatic_carbons</span></div>

<div class="viewcode-block" id="find_benzene_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_benzene_carbons">[docs]</a><span class="k">def</span> <span class="nf">find_benzene_carbons</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">rdchem</span><span class="o">.</span><span class="n">Mol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies indices of carbon atoms that are part of benzene rings in a given molecule.</span>

<span class="sd">    Benzene rings are identified based on the presence of six carbon atoms that are part of an aromatic system,</span>
<span class="sd">    where the carbon atoms are involved in alternating single and double bonds.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol : rdkit.Chem.Mol</span>
<span class="sd">        An RDKit molecule object representing the molecule to be analyzed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of indices corresponding to carbon atoms that are part of benzene rings in the molecule.</span>
<span class="sd">        The indices are zero-based, corresponding to the order in which atoms appear in the RDKit molecule object.</span>
<span class="sd">        If no benzene rings are found, the list will be empty.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; mol = Chem.MolFromSmiles(&quot;C1=CC=CC=C1&quot;)</span>
<span class="sd">    &gt;&gt;&gt; find_benzene_carbons(mol)</span>
<span class="sd">    [0, 1, 2, 3, 4, 5]  # The carbon atoms in the benzene ring.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Benzene rings are detected by finding rings with exactly six carbon atoms that are aromatic.</span>
<span class="sd">    - The function returns a list of indices for the carbon atoms in the benzene ring, excluding other atoms or rings.</span>
<span class="sd">    - The output list may contain duplicates if the molecule contains multiple benzene rings, which are then removed by converting the list to a set.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">benzene_carbons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ri</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetRingInfo</span><span class="p">()</span>
    <span class="n">aromatic_rings</span> <span class="o">=</span> <span class="p">[</span><span class="n">ring</span> <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ri</span><span class="o">.</span><span class="n">AtomRings</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ring</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">aromatic_rings</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ring</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">GetIsAromatic</span><span class="p">():</span>
                <span class="n">benzene_carbons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">benzene_carbons</span><span class="p">))</span>  <span class="c1"># Remove duplicates and return the list</span></div>

<div class="viewcode-block" id="find_ban_carbons"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_ban_carbons">[docs]</a><span class="k">def</span> <span class="nf">find_ban_carbons</span><span class="p">(</span><span class="n">mol</span><span class="p">:</span> <span class="n">rdchem</span><span class="o">.</span><span class="n">Mol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies carbon atoms bonded to exactly two hydrogen atoms and not connected to any other carbons.</span>

<span class="sd">    This function is designed to find carbon atoms in a molecule that are bonded to exactly two hydrogen atoms </span>
<span class="sd">    and are not bonded to other carbon atoms (i.e., the carbon is isolated or terminal, not part of a longer chain).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mol : rdkit.Chem.Mol</span>
<span class="sd">        An RDKit molecule object representing the molecule to be analyzed, before adding explicit hydrogens.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of indices corresponding to carbon atoms that meet the criteria:</span>
<span class="sd">        - Bonded to exactly two hydrogen atoms.</span>
<span class="sd">        - Not connected to any other carbon atoms.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; mol = Chem.MolFromSmiles(&quot;CH3CH2OH&quot;)</span>
<span class="sd">    &gt;&gt;&gt; find_ban_carbons(mol)</span>
<span class="sd">    [0, 3]  # For a molecule like ethanol, the carbon atoms bonded to two hydrogens are indexed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function first adds explicit hydrogens to the molecule to ensure the number of hydrogen atoms can be counted accurately.</span>
<span class="sd">    - It considers only carbon atoms that are bonded to exactly two hydrogens and are not connected to other carbons, excluding carbon-carbon bonds.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Explicitly add hydrogens to the molecule for accurate processing</span>
    <span class="n">mol_with_hs</span> <span class="o">=</span> <span class="n">AddHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

    <span class="c1"># Identify carbon atoms bonded to exactly two hydrogen atoms</span>
    <span class="n">carbon_atoms_with_two_hydrogen</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol_with_hs</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetTotalNumHs</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">carbon_atoms_with_two_hydrogen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>

    <span class="c1"># Determine neighbor atoms for each carbon atom identified above</span>
    <span class="n">neighbor_atoms</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">idx</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mol_with_hs</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;H&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">carbon_atoms_with_two_hydrogen</span>
    <span class="p">}</span>

    <span class="c1"># Find carbon atoms only connected to hydrogen atoms (excluding those connected to other carbons)</span>
    <span class="n">single_linked_carbons</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">neighbor_atoms</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">neighbor</span> <span class="ow">in</span> <span class="n">carbon_atoms_with_two_hydrogen</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">)</span>
    <span class="p">]</span>
    
    <span class="k">return</span> <span class="n">single_linked_carbons</span></div>

<div class="viewcode-block" id="connect_molecules"><a class="viewcode-back" href="../../api/utils.html#coal.utils.connect_molecules">[docs]</a><span class="k">def</span> <span class="nf">connect_molecules</span><span class="p">(</span><span class="n">smiles1</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">smiles2</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connects two molecules at suitable bonding positions, based on various functional groups.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles1 : str</span>
<span class="sd">        The SMILES string representing the first molecule.</span>
<span class="sd">    smiles2 : str</span>
<span class="sd">        The SMILES string representing the second molecule to be connected.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        The SMILES string representing the combined molecule if a valid connection is made,</span>
<span class="sd">        or None if no valid connection can be found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mol1</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles1</span><span class="p">)</span>
    <span class="n">mol2</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles2</span><span class="p">)</span>
    
    <span class="c1"># Define lists of functions to identify suitable connection points on each molecule</span>
    <span class="n">connection_functions1</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">find_aldehyde_carbons</span><span class="p">,</span>
        <span class="n">find_hydroxy_oxygen</span><span class="p">,</span>
        <span class="n">find_ketone_alpha_carbons</span><span class="p">,</span>
        <span class="n">find_alpha_carbons</span><span class="p">,</span> 
        <span class="n">find_aliphatic_carbons</span><span class="p">,</span>
        <span class="n">find_benzene_carbons</span>
    <span class="p">]</span>
    
    <span class="n">connection_functions2</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">find_aldehyde_carbons</span><span class="p">,</span>
        <span class="n">find_hydroxy_oxygen</span><span class="p">,</span>
        <span class="n">find_ketone_alpha_carbons</span><span class="p">,</span>
        <span class="n">find_alpha_carbons</span><span class="p">,</span>
        <span class="n">find_aliphatic_carbons</span><span class="p">,</span>
        <span class="n">find_benzene_carbons</span>
    <span class="p">]</span>
    
    <span class="c1"># Outer loop to iterate through possible connection points on mol1</span>
    <span class="k">for</span> <span class="n">find_atoms1</span> <span class="ow">in</span> <span class="n">connection_functions1</span><span class="p">:</span>
        <span class="n">atoms1</span> <span class="o">=</span> <span class="n">find_atoms1</span><span class="p">(</span><span class="n">mol1</span><span class="p">)</span>
        <span class="n">atoms1</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">atoms1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">mol1</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;H&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">atoms1</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">atoms1</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">find_ban_carbons</span><span class="p">(</span><span class="n">mol1</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">atoms1</span><span class="p">:</span>
            <span class="c1"># Inner loop to iterate through possible connection points on mol2</span>
            <span class="k">for</span> <span class="n">find_atoms2</span> <span class="ow">in</span> <span class="n">connection_functions2</span><span class="p">:</span>
                <span class="n">atoms2</span> <span class="o">=</span> <span class="n">find_atoms2</span><span class="p">(</span><span class="n">mol2</span><span class="p">)</span>
                <span class="n">atoms2</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">atoms2</span> <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">neighbor</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">mol2</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;H&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">atoms2</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">atoms2</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">find_ban_carbons</span><span class="p">(</span><span class="n">mol2</span><span class="p">)]</span>
                
                <span class="c1"># Ensure no connection between two hydroxy groups</span>
                <span class="k">if</span> <span class="n">atoms2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">find_atoms1</span> <span class="o">==</span> <span class="n">find_hydroxy_oxygen</span> <span class="ow">and</span> <span class="n">find_atoms2</span> <span class="o">==</span> <span class="n">find_hydroxy_oxygen</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">atom1_idx</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">atoms1</span><span class="p">)</span>
                        <span class="n">atom2_idx</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">atoms2</span><span class="p">)</span>
                        <span class="n">new_mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">CombineMols</span><span class="p">(</span><span class="n">mol1</span><span class="p">,</span> <span class="n">mol2</span><span class="p">)</span>
                        <span class="n">edit_mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">EditableMol</span><span class="p">(</span><span class="n">new_mol</span><span class="p">)</span>
                        <span class="c1"># Correct index for atom2 after combining molecules</span>
                        <span class="n">combined_atom2_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol1</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">())</span> <span class="o">+</span> <span class="n">atom2_idx</span>
                        <span class="n">edit_mol</span><span class="o">.</span><span class="n">AddBond</span><span class="p">(</span><span class="n">atom1_idx</span><span class="p">,</span> <span class="n">combined_atom2_idx</span><span class="p">,</span> <span class="n">rdchem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">)</span>
                        <span class="n">connected_mol</span> <span class="o">=</span> <span class="n">edit_mol</span><span class="o">.</span><span class="n">GetMol</span><span class="p">()</span>
                        <span class="n">Chem</span><span class="o">.</span><span class="n">SanitizeMol</span><span class="p">(</span><span class="n">connected_mol</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">connected_mol</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">continue</span>  <span class="c1"># If sanitization fails or invalid connection, try again</span>
                    
    <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># If no valid connection was found</span></div>

<div class="viewcode-block" id="show_ring_carbon_numbers"><a class="viewcode-back" href="../../api/utils.html#coal.utils.show_ring_carbon_numbers">[docs]</a><span class="k">def</span> <span class="nf">show_ring_carbon_numbers</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

    <span class="c1"># Extract the indices of the ring carbons with exactly one hydrogen atom</span>
    <span class="n">potential_ring_carbons</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()</span> 
                              <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">IsInRing</span><span class="p">()</span> 
                              <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span> 
                              <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span> <span class="k">if</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;H&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
    
    <span class="n">ring_info</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetRingInfo</span><span class="p">()</span>
    <span class="n">selected_ring_carbons</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Further filter the ring carbons based on participation in specific ring sizes</span>
    <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ring_info</span><span class="o">.</span><span class="n">AtomRings</span><span class="p">():</span>
        <span class="n">intersect</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">potential_ring_carbons</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]:</span>  <span class="c1"># If interested in rings of size 3 to 5</span>
            <span class="n">selected_ring_carbons</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">intersect</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">selected_ring_carbons</span><span class="p">))</span>  <span class="c1"># Ensure uniqueness and return</span></div>

<div class="viewcode-block" id="select_carbons_from_different_rings"><a class="viewcode-back" href="../../api/utils.html#coal.utils.select_carbons_from_different_rings">[docs]</a><span class="k">def</span> <span class="nf">select_carbons_from_different_rings</span><span class="p">(</span><span class="n">current_molecule</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ring_carbons</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select up to `n` carbon atoms from different rings within the given molecule.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    current_molecule : str</span>
<span class="sd">        SMILES representation of the molecule.</span>
<span class="sd">    ring_carbons : list</span>
<span class="sd">        A list of indices of carbon atoms within rings.</span>
<span class="sd">    n : int</span>
<span class="sd">        The number of carbon atoms to select, each from a different ring.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    selected_indices : list</span>
<span class="sd">        A list of selected carbon atom indices, each from different rings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">current_molecule</span><span class="p">)</span>
    <span class="n">ring_info</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetRingInfo</span><span class="p">()</span>
    <span class="n">selected_indices</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ring_info</span><span class="o">.</span><span class="n">AtomRings</span><span class="p">():</span>
        <span class="c1"># Check if this ring contains any of the specified ring carbons</span>
        <span class="n">ring_contains_target_carbon</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ring</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ring_carbons</span> <span class="ow">and</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">selected_indices</span><span class="p">:</span>
                <span class="n">selected_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">ring_contains_target_carbon</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>  <span class="c1"># Break after adding one carbon from the current ring</span>
        
        <span class="c1"># Exit the loop early if we&#39;ve selected the desired number of carbons</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selected_indices</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">break</span>
    
    <span class="k">return</span> <span class="n">selected_indices</span></div>

<div class="viewcode-block" id="count_atoms"><a class="viewcode-back" href="../../api/utils.html#coal.utils.count_atoms">[docs]</a><span class="k">def</span> <span class="nf">count_atoms</span><span class="p">(</span><span class="n">smiles_input</span><span class="p">:</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts the number of each specified element in a single SMILES string or a list of SMILES strings.</span>
<span class="sd">    Ensures all expected elements are included in the result dictionary, even if their count is 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles_input : str or list</span>
<span class="sd">        A single SMILES string or a list of SMILES strings representing molecule(s).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with element symbols as keys and their total counts across all input molecules as values.</span>
<span class="sd">        Includes &#39;C&#39;, &#39;H&#39;, &#39;O&#39;, &#39;N&#39;, and &#39;S&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">atom_counts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>  <span class="c1"># Predefine expected elements with counts of 0</span>

    <span class="c1"># Check if the input is a single SMILES string or a list of SMILES strings</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">smiles_input</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">smiles_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">smiles_input</span><span class="p">]</span>  <span class="c1"># Convert to list for uniform processing</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">smiles_input</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">smiles_list</span> <span class="o">=</span> <span class="n">smiles_input</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unsupported input type. Please provide a SMILES string or a list of SMILES strings.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Traverse the SMILES list</span>
    <span class="k">for</span> <span class="n">smiles</span> <span class="ow">in</span> <span class="n">smiles_list</span><span class="p">:</span>
        <span class="n">molecule</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">molecule</span><span class="p">:</span>  <span class="c1"># Check if the molecule object was created successfully</span>
            <span class="n">molecule</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">atom_counts</span><span class="p">:</span>
                    <span class="n">atom_counts</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">atom_counts</span></div>

<div class="viewcode-block" id="balance_c_and_n_atoms"><a class="viewcode-back" href="../../api/utils.html#coal.utils.balance_c_and_n_atoms">[docs]</a><span class="k">def</span> <span class="nf">balance_c_and_n_atoms</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_element_counts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modifies a molecule by replacing carbon atoms with nitrogen to meet target element counts,</span>
<span class="sd">    while avoiding changes in benzene rings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        SMILES representation of the molecule.</span>
<span class="sd">    target_element_counts : dict</span>
<span class="sd">        Dictionary with target counts for elements, e.g., {&#39;C&#39;: x, &#39;N&#39;: y}.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_smiles : str</span>
<span class="sd">        A new SMILES string of the modified molecule, or the original SMILES if the desired modifications cannot be made.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
    <span class="n">new_mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">RWMol</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>  <span class="c1"># Create a writable copy of the molecule for modifications.</span>

    <span class="c1"># Analyze ring information to avoid replacing carbon atoms in benzene rings</span>
    <span class="n">ssr</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetSymmSSSR</span><span class="p">(</span><span class="n">new_mol</span><span class="p">)</span>
    <span class="n">benzene_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">ssr</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>  <span class="c1"># Assuming benzene rings are six-membered</span>
            <span class="n">ring_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ring</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">ring_atoms</span><span class="p">):</span>
                <span class="n">benzene_indices</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>

    <span class="n">current_c_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">new_mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
    <span class="n">target_c_count</span> <span class="o">=</span> <span class="n">target_element_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">current_c_count</span><span class="p">)</span>

    <span class="n">c_to_replace</span> <span class="o">=</span> <span class="n">current_c_count</span> <span class="o">-</span> <span class="n">target_c_count</span>

    <span class="k">if</span> <span class="n">c_to_replace</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Replace some carbon atoms with nitrogen atoms</span>
        <span class="n">c_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">new_mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">()</span> <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">benzene_indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">c_to_replace</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_indices</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: Cannot replace more carbon atoms with nitrogen atoms.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">new_mol</span><span class="p">)</span>
        <span class="n">selected_indices</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">c_indices</span><span class="p">,</span> <span class="n">c_to_replace</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">selected_indices</span><span class="p">:</span>
            <span class="n">new_mol</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">SetAtomicNum</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>  <span class="c1"># Set atomic number to 7 for nitrogen</span>

    <span class="n">new_smiles</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">new_mol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_smiles</span></div>

<div class="viewcode-block" id="find_atom_indices"><a class="viewcode-back" href="../../api/utils.html#coal.utils.find_atom_indices">[docs]</a><span class="k">def</span> <span class="nf">find_atom_indices</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">atom_symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the indices of specified atoms in a molecule. For oxygen atoms,</span>
<span class="sd">    it specifically returns those bonded to exactly two carbon atoms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        SMILES representation of the molecule.</span>
<span class="sd">    atom_symbol : str</span>
<span class="sd">        The symbol of the atom to find (&#39;O&#39; for oxygen, &#39;S&#39; for sulfur).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of indices for the specified atoms under the given conditions.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">molecule</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
    <span class="n">atom_indices</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="n">atom_symbol</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atom_symbol</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
                <span class="c1"># Check if the oxygen is bonded to exactly two carbon atoms</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetNeighbors</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">):</span>
                    <span class="n">atom_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">atom_symbol</span> <span class="o">==</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span>
                <span class="c1"># Directly add the sulfur atom&#39;s index, or apply additional checks here if needed</span>
                <span class="n">atom_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">GetIdx</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">atom_indices</span></div>

<div class="viewcode-block" id="balance_o_and_s_atoms"><a class="viewcode-back" href="../../api/utils.html#coal.utils.balance_o_and_s_atoms">[docs]</a><span class="k">def</span> <span class="nf">balance_o_and_s_atoms</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_element_counts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modifies a molecule by replacing sulfur atoms with oxygen, or vice versa,</span>
<span class="sd">    to meet target element counts for oxygen and sulfur.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        SMILES representation of the molecule.</span>
<span class="sd">    target_element_counts : dict</span>
<span class="sd">        Dictionary with target counts for oxygen (&#39;O&#39;) and sulfur (&#39;S&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        A new SMILES string of the modified molecule.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">molecule</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
    <span class="n">oxygen_indices</span> <span class="o">=</span> <span class="n">find_atom_indices</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">)</span>
    <span class="n">sulfur_indices</span> <span class="o">=</span> <span class="n">find_atom_indices</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">)</span>

    <span class="n">current_O_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">oxygen_indices</span><span class="p">)</span>
    <span class="n">current_S_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sulfur_indices</span><span class="p">)</span>

    <span class="n">periodic_table</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">GetPeriodicTable</span><span class="p">()</span>

    <span class="c1"># Replace S with O if current_O_count &lt; target_O_count</span>
    <span class="k">while</span> <span class="n">current_O_count</span> <span class="o">&lt;</span> <span class="n">target_element_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sulfur_indices</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sulfur_indices</span><span class="p">)</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">SetAtomicNum</span><span class="p">(</span><span class="n">periodic_table</span><span class="o">.</span><span class="n">GetAtomicNumber</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">))</span>
        <span class="n">sulfur_indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">oxygen_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>  <span class="c1"># Update indices list</span>
        <span class="n">current_O_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">current_S_count</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># Replace O with S if current_S_count &lt; target_S_count</span>
    <span class="k">while</span> <span class="n">current_S_count</span> <span class="o">&lt;</span> <span class="n">target_element_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">oxygen_indices</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">oxygen_indices</span><span class="p">)</span>
        <span class="n">molecule</span><span class="o">.</span><span class="n">GetAtomWithIdx</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">SetAtomicNum</span><span class="p">(</span><span class="n">periodic_table</span><span class="o">.</span><span class="n">GetAtomicNumber</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">))</span>
        <span class="n">oxygen_indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">sulfur_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>  <span class="c1"># Update indices list</span>
        <span class="n">current_O_count</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">current_S_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolToSmiles</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="n">isomericSmiles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="calculate_unsaturated_carbon_ratio"><a class="viewcode-back" href="../../api/utils.html#coal.utils.calculate_unsaturated_carbon_ratio">[docs]</a><span class="k">def</span> <span class="nf">calculate_unsaturated_carbon_ratio</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the ratio of unsaturated carbon atoms (participating in double or triple bonds) </span>
<span class="sd">    to the total number of carbon atoms in a molecule represented by a SMILES string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        SMILES representation of the molecule.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The ratio of unsaturated carbon atoms to total carbon atoms in the molecule.</span>
<span class="sd">        Returns 0 if there are no carbon atoms in the molecule or if the input SMILES is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 从SMILES字符串创建一个RDKit分子对象</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">mol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;提供的SMILES字符串无效或格式有误。&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># 或者根据你的需求返回其他表示错误的值</span>
    
    <span class="n">total_carbons</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 总碳原子数量</span>
    <span class="n">unsaturated_carbons</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 不饱和碳原子数量</span>

    <span class="c1"># 遍历分子中的所有原子</span>
    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>  <span class="c1"># 如果原子是碳原子</span>
            <span class="n">total_carbons</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># 检查碳原子是否不饱和（参与了双键或三键）</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">bond</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">:</span>  <span class="c1"># 如果发现了双键或三键</span>
                    <span class="n">unsaturated_carbons</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">break</span>  <span class="c1"># 不需要检查其他键，一个不饱和键就足够了</span>
    
    <span class="c1"># 如果没有碳原子，返回比例0</span>
    <span class="k">if</span> <span class="n">total_carbons</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="c1"># 计算不饱和碳原子占总碳原子的比例</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">unsaturated_carbons</span> <span class="o">/</span> <span class="n">total_carbons</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;不饱和碳原子数量: </span><span class="si">{</span><span class="n">unsaturated_carbons</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ratio</span></div>

<div class="viewcode-block" id="count_property"><a class="viewcode-back" href="../../api/utils.html#coal.utils.count_property">[docs]</a><span class="k">def</span> <span class="nf">count_property</span><span class="p">(</span><span class="n">smiles_input</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Counts specified elements and their types (e.g., unsaturated or aliphatic carbons) in one or more SMILES strings.</span>
<span class="sd">    </span>
<span class="sd">    Specifically counts:</span>
<span class="sd">    - &#39;C_N_ar&#39;: Unsaturated carbon or nitrogen atoms (those participating in double or triple bonds).</span>
<span class="sd">    - &#39;C_al&#39;: Aliphatic (single-bonded) carbon atoms.</span>
<span class="sd">    - &#39;O_S&#39;: Oxygen and sulfur atoms.</span>
<span class="sd">    - &#39;H&#39;: Hydrogen atoms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles_input : str or list</span>
<span class="sd">        A single SMILES string or a list of SMILES strings representing one or more molecules.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary with the counts of each property: {&#39;C_N_ar&#39;, &#39;C_al&#39;, &#39;O_S&#39;, &#39;H&#39;}.</span>
<span class="sd">        The counts reflect the number of atoms of each type found in the provided molecule(s).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">property_counts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C_N_ar&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;C_al&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;O_S&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

    <span class="c1"># Check if the input is a single SMILES string or a list of SMILES strings</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">smiles_input</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">smiles_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">smiles_input</span><span class="p">]</span>  <span class="c1"># Convert to list for uniform processing</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">smiles_input</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">smiles_list</span> <span class="o">=</span> <span class="n">smiles_input</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unsupported input type. Please provide a SMILES string or a list of SMILES strings.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Traverse the SMILES list</span>
    <span class="k">for</span> <span class="n">smiles</span> <span class="ow">in</span> <span class="n">smiles_list</span><span class="p">:</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span>
        <span class="n">mol_with_hs</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol_with_hs</span><span class="o">.</span><span class="n">GetAtoms</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">or</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span>
                <span class="c1"># Check if the atom is part of an unsaturated structure (double or triple bond)</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">bond</span><span class="o">.</span><span class="n">GetBondType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">BondType</span><span class="o">.</span><span class="n">SINGLE</span> <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetBonds</span><span class="p">()):</span>
                    <span class="n">property_counts</span><span class="p">[</span><span class="s1">&#39;C_N_ar&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Count as unsaturated C (or N)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">property_counts</span><span class="p">[</span><span class="s1">&#39;C_al&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Count as aliphatic carbon</span>
            <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">]:</span>
                <span class="n">property_counts</span><span class="p">[</span><span class="s1">&#39;O_S&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Count oxygen and sulfur atoms</span>
            <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">GetSymbol</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
                <span class="n">property_counts</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Count hydrogen atoms</span>

    <span class="k">return</span> <span class="n">property_counts</span></div>

<div class="viewcode-block" id="drawMolecule"><a class="viewcode-back" href="../../api/utils.html#coal.utils.drawMolecule">[docs]</a><span class="k">def</span> <span class="nf">drawMolecule</span><span class="p">(</span><span class="n">smiles</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws a molecule from a given SMILES string and displays the image.</span>
<span class="sd">    </span>
<span class="sd">    This function uses RDKit to create a molecule object from the provided SMILES string</span>
<span class="sd">    and then generates an image of the molecule, which is displayed using the default image viewer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles : str</span>
<span class="sd">        The SMILES string representing the molecule to be drawn.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        This function does not return a value, it directly displays the molecule&#39;s image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mol</span> <span class="o">=</span> <span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">,</span> <span class="n">sanitize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># Create the molecule without sanitization</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">Draw</span><span class="o">.</span><span class="n">MolToImage</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>  <span class="c1"># Generate the image</span>
    <span class="n">img</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># Display the image</span></div>

<div class="viewcode-block" id="drawMolecules"><a class="viewcode-back" href="../../api/utils.html#coal.utils.drawMolecules">[docs]</a><span class="k">def</span> <span class="nf">drawMolecules</span><span class="p">(</span><span class="n">smiles_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">molsPerRow</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">maxMols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Draws a grid image of molecules from a list of SMILES strings.</span>

<span class="sd">    This function takes a list of SMILES strings, converts them into RDKit molecule objects, and generates a grid image.</span>
<span class="sd">    It also provides a summary of the molecular properties (C, N, O, H counts) for each molecule in the grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    smiles_list : list of str</span>
<span class="sd">        A list of SMILES strings representing the molecules to be drawn.</span>
<span class="sd">        </span>
<span class="sd">    molsPerRow : int</span>
<span class="sd">        The number of molecules to display per row in the grid image.</span>
<span class="sd">        </span>
<span class="sd">    maxMols : int, optional, default=100</span>
<span class="sd">        The maximum number of molecules to display in the grid. If more molecules are provided, they will be truncated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of dict</span>
<span class="sd">        A list of dictionaries, each containing molecular property counts (C, N, O, H) for each molecule.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert SMILES strings to RDKit molecule objects and add hydrogens</span>
    <span class="n">molecules</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">MolFromSmiles</span><span class="p">(</span><span class="n">smiles</span><span class="p">)</span> <span class="k">for</span> <span class="n">smiles</span> <span class="ow">in</span> <span class="n">smiles_list</span><span class="p">]</span>
    <span class="n">molecules</span> <span class="o">=</span> <span class="p">[</span><span class="n">AllChem</span><span class="o">.</span><span class="n">AddHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span> <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">molecules</span><span class="p">]</span>

    <span class="c1"># Optionally remove hydrogens for a cleaner drawing</span>
    <span class="n">molecules_noH</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chem</span><span class="o">.</span><span class="n">RemoveHs</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span> <span class="k">for</span> <span class="n">mol</span> <span class="ow">in</span> <span class="n">molecules</span><span class="p">]</span>

    <span class="c1"># Draw and return the grid image of molecules</span>
    <span class="n">mol_property</span> <span class="o">=</span> <span class="p">[</span><span class="n">count_property</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">smiles_list</span><span class="p">]</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">Draw</span><span class="o">.</span><span class="n">MolsToGridImage</span><span class="p">(</span><span class="n">molecules_noH</span><span class="p">,</span> <span class="n">molsPerRow</span><span class="o">=</span><span class="n">molsPerRow</span><span class="p">,</span> <span class="n">subImgSize</span><span class="o">=</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span> <span class="n">maxMols</span><span class="o">=</span><span class="n">maxMols</span><span class="p">,</span> <span class="n">legends</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mol_property</span><span class="p">])</span>
    <span class="n">display</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mol_property</span></div>

<div class="viewcode-block" id="calculate_mass_percentages"><a class="viewcode-back" href="../../api/utils.html#coal.utils.calculate_mass_percentages">[docs]</a><span class="k">def</span> <span class="nf">calculate_mass_percentages</span><span class="p">(</span><span class="n">atom_counts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the mass percentages of elements based on their counts in a molecule.</span>

<span class="sd">    This function uses the atomic masses of carbon, hydrogen, oxygen, nitrogen, and sulfur to compute</span>
<span class="sd">    the mass percentages of each element in the molecule, given the counts of each element.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    atom_counts : dict of {str: int}</span>
<span class="sd">        A dictionary with element symbols as keys (e.g., &#39;C&#39;, &#39;H&#39;, &#39;O&#39;) and their counts in the molecule as values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict of {str: float}</span>
<span class="sd">        A dictionary with element symbols as keys and their mass percentages as values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Atomic masses in atomic mass units (amu)</span>
    <span class="n">atomic_masses</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">12.01</span><span class="p">,</span>
        <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mf">1.008</span><span class="p">,</span>
        <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="mf">16.00</span><span class="p">,</span>
        <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="mf">14.01</span><span class="p">,</span>
        <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="mf">32.06</span>
    <span class="p">}</span>
    
    <span class="c1"># Calculate the total mass for each element</span>
    <span class="n">masses</span> <span class="o">=</span> <span class="p">{</span><span class="n">element</span><span class="p">:</span> <span class="n">count</span> <span class="o">*</span> <span class="n">atomic_masses</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="k">for</span> <span class="n">element</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">atom_counts</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    
    <span class="c1"># Calculate the total mass of the molecule</span>
    <span class="n">total_mass</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">masses</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    
    <span class="c1"># Calculate the mass percentages of each element</span>
    <span class="n">mass_percentages</span> <span class="o">=</span> <span class="p">{</span><span class="n">element</span><span class="p">:</span> <span class="p">(</span><span class="n">mass</span> <span class="o">/</span> <span class="n">total_mass</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">for</span> <span class="n">element</span><span class="p">,</span> <span class="n">mass</span> <span class="ow">in</span> <span class="n">masses</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    
    <span class="k">return</span> <span class="n">mass_percentages</span></div>

<div class="viewcode-block" id="ad2daf"><a class="viewcode-back" href="../../api/utils.html#coal.utils.ad2daf">[docs]</a><span class="k">def</span> <span class="nf">ad2daf</span><span class="p">(</span><span class="n">C</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">H</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">S</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the element percentages from the AD (as-determined) basis to the DAF (dry, ash-free) basis.</span>

<span class="sd">    This function calculates the percentage of each element (C, N, H, S, and O) on the DAF basis,</span>
<span class="sd">    given their values on the AD basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C : float</span>
<span class="sd">        Carbon percentage in the AD basis.</span>
<span class="sd">    N : float</span>
<span class="sd">        Nitrogen percentage in the AD basis.</span>
<span class="sd">    H : float</span>
<span class="sd">        Hydrogen percentage in the AD basis.</span>
<span class="sd">    S : float</span>
<span class="sd">        Sulfur percentage in the AD basis.</span>
<span class="sd">    M : float</span>
<span class="sd">        Moisture percentage (unused in calculations but might be part of input data).</span>
<span class="sd">    A : float</span>
<span class="sd">        Ash percentage (unused in calculations but might be part of input data).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of float</span>
<span class="sd">        A tuple containing the percentages of Carbon (C), Nitrogen (N), Hydrogen (H), Sulfur (S),</span>
<span class="sd">        and Oxygen (O) on the DAF basis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the oxygen percentage in AD basis</span>
    <span class="n">O</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">-</span> <span class="p">(</span><span class="n">C</span> <span class="o">+</span> <span class="n">N</span> <span class="o">+</span> <span class="n">H</span> <span class="o">+</span> <span class="n">S</span> <span class="o">+</span> <span class="n">M</span> <span class="o">+</span> <span class="n">A</span><span class="p">)</span>
    
    <span class="c1"># Calculate the total sum of C, N, H, S, and O on AD basis</span>
    <span class="n">total_CNHSO_ad</span> <span class="o">=</span> <span class="n">C</span> <span class="o">+</span> <span class="n">N</span> <span class="o">+</span> <span class="n">H</span> <span class="o">+</span> <span class="n">S</span> <span class="o">+</span> <span class="n">O</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;O_ad=&#39;</span><span class="p">,</span> <span class="n">O</span><span class="p">)</span>
    
    <span class="c1"># Calculate the percentage of each element on DAF basis</span>
    <span class="n">C_daf</span> <span class="o">=</span> <span class="n">C</span> <span class="o">/</span> <span class="n">total_CNHSO_ad</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="n">N_daf</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">total_CNHSO_ad</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="n">H_daf</span> <span class="o">=</span> <span class="n">H</span> <span class="o">/</span> <span class="n">total_CNHSO_ad</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="n">S_daf</span> <span class="o">=</span> <span class="n">S</span> <span class="o">/</span> <span class="n">total_CNHSO_ad</span> <span class="o">*</span> <span class="mi">100</span>
    <span class="n">O_daf</span> <span class="o">=</span> <span class="n">O</span> <span class="o">/</span> <span class="n">total_CNHSO_ad</span> <span class="o">*</span> <span class="mi">100</span>
    
    <span class="k">return</span> <span class="n">C_daf</span><span class="p">,</span> <span class="n">N_daf</span><span class="p">,</span> <span class="n">H_daf</span><span class="p">,</span> <span class="n">S_daf</span><span class="p">,</span> <span class="n">O_daf</span></div>

<div class="viewcode-block" id="daf2ad"><a class="viewcode-back" href="../../api/utils.html#coal.utils.daf2ad">[docs]</a><span class="k">def</span> <span class="nf">daf2ad</span><span class="p">(</span><span class="n">C_daf</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">N_daf</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">H_daf</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">S_daf</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">O_daf</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the element percentages from the DAF (dry, ash-free) basis to the AD (as-determined) basis.</span>

<span class="sd">    This function calculates the percentage of each element (C, N, H, S, and O) on the AD basis,</span>
<span class="sd">    given their values on the DAF basis, and considering moisture and ash content.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C_daf : float</span>
<span class="sd">        Carbon percentage in the DAF basis.</span>
<span class="sd">    N_daf : float</span>
<span class="sd">        Nitrogen percentage in the DAF basis.</span>
<span class="sd">    H_daf : float</span>
<span class="sd">        Hydrogen percentage in the DAF basis.</span>
<span class="sd">    S_daf : float</span>
<span class="sd">        Sulfur percentage in the DAF basis.</span>
<span class="sd">    O_daf : float</span>
<span class="sd">        Oxygen percentage in the DAF basis.</span>
<span class="sd">    M : float</span>
<span class="sd">        Moisture percentage.</span>
<span class="sd">    A : float</span>
<span class="sd">        Ash percentage.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple of float</span>
<span class="sd">        A tuple containing the percentages of Carbon (C), Nitrogen (N), Hydrogen (H), Sulfur (S),</span>
<span class="sd">        and Oxygen (O) on the AD basis.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Given the following input data:</span>
<span class="sd">    </span>
<span class="sd">    C_daf = 83.96</span>
<span class="sd">    N_daf = 3.81</span>
<span class="sd">    H_daf = 3.31</span>
<span class="sd">    S_daf = 0.39</span>
<span class="sd">    O_daf = 8.99</span>
<span class="sd">    M = 2.51  # Moisture</span>
<span class="sd">    A = 1.66  # Ash</span>

<span class="sd">    The function is called as:</span>

<span class="sd">    C_ad, N_ad, H_ad, S_ad, O_ad = daf2ad(C_daf, N_daf, H_daf, S_daf, O_daf, M, A)</span>

<span class="sd">    The output will be:</span>

<span class="sd">    ad基准下百分比: C_ad, N_ad, H_ad, S_ad, O_ad</span>
<span class="sd">    CNHSOMA和: C_ad + N_ad + H_ad + S_ad + O_ad + M + A</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Conversion factor for converting from DAF to AD</span>
    <span class="n">conversion_factor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="n">A</span><span class="p">))</span> <span class="o">/</span> <span class="mi">100</span>
    
    <span class="c1"># Calculate the element percentages on AD basis</span>
    <span class="n">C_ad</span> <span class="o">=</span> <span class="n">C_daf</span> <span class="o">*</span> <span class="n">conversion_factor</span>
    <span class="n">N_ad</span> <span class="o">=</span> <span class="n">N_daf</span> <span class="o">*</span> <span class="n">conversion_factor</span>
    <span class="n">H_ad</span> <span class="o">=</span> <span class="n">H_daf</span> <span class="o">*</span> <span class="n">conversion_factor</span>
    <span class="n">S_ad</span> <span class="o">=</span> <span class="n">S_daf</span> <span class="o">*</span> <span class="n">conversion_factor</span>
    
    <span class="c1"># Calculate the total sum of C, N, H, S on AD basis</span>
    <span class="n">total_CNHS_ad</span> <span class="o">=</span> <span class="n">C_ad</span> <span class="o">+</span> <span class="n">N_ad</span> <span class="o">+</span> <span class="n">H_ad</span> <span class="o">+</span> <span class="n">S_ad</span>
    
    <span class="c1"># Calculate oxygen percentage on AD basis</span>
    <span class="n">O_ad</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">-</span> <span class="p">(</span><span class="n">total_CNHS_ad</span> <span class="o">+</span> <span class="n">M</span> <span class="o">+</span> <span class="n">A</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">C_ad</span><span class="p">,</span> <span class="n">N_ad</span><span class="p">,</span> <span class="n">H_ad</span><span class="p">,</span> <span class="n">S_ad</span><span class="p">,</span> <span class="n">O_ad</span></div>


<div class="viewcode-block" id="calculate_MA"><a class="viewcode-back" href="../../api/utils.html#coal.utils.calculate_MA">[docs]</a><span class="k">def</span> <span class="nf">calculate_MA</span><span class="p">(</span><span class="n">C_ad</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">N_ad</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">H_ad</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">S_ad</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">C_daf</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">O_daf</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the sum of moisture (M) and ash (A) content based on the element percentages </span>
<span class="sd">    in the AD (as-determined) basis and DAF (dry, ash-free) basis for a given material.</span>

<span class="sd">    This function computes the total moisture and ash content (M + A) based on the known </span>
<span class="sd">    values of carbon, nitrogen, hydrogen, sulfur, and oxygen in both AD and DAF forms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    C_ad : float</span>
<span class="sd">        Carbon percentage in the AD basis.</span>
<span class="sd">    N_ad : float</span>
<span class="sd">        Nitrogen percentage in the AD basis.</span>
<span class="sd">    H_ad : float</span>
<span class="sd">        Hydrogen percentage in the AD basis.</span>
<span class="sd">    S_ad : float</span>
<span class="sd">        Sulfur percentage in the AD basis.</span>
<span class="sd">    C_daf : float</span>
<span class="sd">        Carbon percentage in the DAF basis.</span>
<span class="sd">    O_daf : float</span>
<span class="sd">        Oxygen percentage in the DAF basis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        The sum of moisture and ash content (M + A) on the AD basis.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Given the following input data:</span>

<span class="sd">    C_ad = 80.92</span>
<span class="sd">    N_ad = 3.49   # Nitrogen</span>
<span class="sd">    H_ad = 3.03   # Hydrogen</span>
<span class="sd">    S_ad = 0.38   # Sulfur</span>
<span class="sd">    C_daf = 83.86</span>
<span class="sd">    O_daf = 8.99</span>

<span class="sd">    The function is called as:</span>

<span class="sd">    MA_sum = calculate_MA(C_ad, N_ad, H_ad, S_ad, C_daf, O_daf)</span>

<span class="sd">    The output will be:</span>

<span class="sd">    MA_sum: 8.29</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the total CNHS percentage on the AD basis</span>
    <span class="n">total_CNHS_ad</span> <span class="o">=</span> <span class="n">C_ad</span> <span class="o">+</span> <span class="n">N_ad</span> <span class="o">+</span> <span class="n">H_ad</span> <span class="o">+</span> <span class="n">S_ad</span>
    
    <span class="c1"># Calculate O_ad based on the ratio between C_ad and C_daf</span>
    <span class="n">O_ad</span> <span class="o">=</span> <span class="p">(</span><span class="n">C_ad</span> <span class="o">/</span> <span class="n">C_daf</span><span class="p">)</span> <span class="o">*</span> <span class="n">O_daf</span>
    
    <span class="c1"># Calculate the total sum of moisture (M) and ash (A)</span>
    <span class="n">MA_sum</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">-</span> <span class="p">(</span><span class="n">total_CNHS_ad</span> <span class="o">+</span> <span class="n">O_ad</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">MA_sum</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Haodong Liu.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>